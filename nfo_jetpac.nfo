insert ; ----------------------------------------------------------
insert ;  This is the reverse-engineered source code for the
insert ;  game 'JETPAC' written by Ultimate Play The Game.
insert ; ----------------------------------------------------------
insert
;
; Start of disassembly instructions
word     2000-2003
comment  2004
comment  2004 Initial value table for VIC setup 16 bytes
label    2004 VIC_Init_Tab
lcomment 2004 VIC_R0_H_Ctr     Left edge of TV picture and interlace switch.
const    2004-201B
break    2004-2013
lcomment 2005 VIC_R1_V_Ctr
lcomment 2006 VIC_R2_Num_Cols
lcomment 2007 VIC_R3_Num_Rows
lcomment 2008 VIC_R4_TV_Raster
lcomment 2009 VIC_R5_CM_Start
lcomment 200A VIC_R6_H_LightP
lcomment 200B VIC_R7_V_LightP
lcomment 200C VIC_R8_Paddle_X
lcomment 200D VIC_R9_Paddle_Y
lcomment 200E VIC_RA_Frq_Osc1
lcomment 200F VIC_RB_Frq_Osc2
lcomment 2010 VIC_RC_Frq_Osc3
lcomment 2011 VIC_RD_Frq_Noise
lcomment 2012 VIC_RE_Vol_Colour
lcomment 2013 VIC_RF_BckBdrCol
comment  2014
comment  2014 Quick lookup for BIT instruction
label    2014 MASK_00000001
binary   2014-201B
label    2015 MASK_00000010
label    2016 MASK_00000100
label    2017 MASK_00001000
label    2018 MASK_00010000
label    2019 MASK_00100000
label    201A MASK_01000000
label    201B MASK_10000000
comment  201C
comment  201C +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     201C NMI_Interrupt_Hardler
comment  201D
comment  201D ----------------------------------------------------------
comment  201D Starts here
comment  201D ----------------------------------------------------------
lcomment 201D Disable Interrupts
lcomment 201E Reset stack pointer
lcomment 2021 Clear Decimal flag
comment  2022
comment  2022 Setup NMI interrupt vector to service routine at $201C
comment  202C
comment  2032
comment  2032 Setup I/O data direction and interrupt enables
comment  2041
comment  2044
comment  2044 Set VIA outputs for keyboard scan
lcomment 2046 Data I/O register (User port & RS-232) i.e. not used
lcomment 2049 Data I/O register (Keybd col scan, Cassette, Joy)
comment  204C
comment  204C Setup IRQ interrupt vector to service routine at $25E0
comment  2056
comment  2056 Reset the VIC registers
lcomment 2056 16 registers
label    2058 Reset_VIC
comment  2061
comment  2061 Initialize Screen RAM i.e. map screen tiles to User-Defined Graphics RAM
comment  2061 Each character is a 16x8 tile i.e. double height, thus play area
comment  2061 is decimal 11 Rows x 23 Columns
comment  2061 0200  00 0B 16 21 2C 37 42 4D 58 63 6E 79 84 8F 9A A5 B0 BB C6 D1 DC E7 F2
comment  2061 0217  01 0C 17 22 2D 38 43 4E 59 64 6F 7A 85 90 9B A6 B1 BC C7 D2 DD E8 F3
comment  2061 022E  02 0D 18 23 2E 39 44 4F 5A 65 70 7B 86 91 9C A7 B2 BD C8 D3 DE E9 F4
comment  2061 0245  03 0E 19 24 2F 3A 45 50 5B 66 71 7C 87 92 9D A8 B3 BE C9 D4 DF EA F5
comment  2061 025C  04 0F 1A 25 30 3B 46 51 5C 67 72 7D 88 93 9E A9 B4 BF CA D5 E0 EB F6
comment  2061 0273  05 10 1B 26 31 3C 47 52 5D 68 73 7E 89 94 9F AA B5 C0 CB D6 E1 EC F7
comment  2061 028A  06 11 1C 27 32 3D 48 53 5E 69 74 7F 8A 95 A0 AB B6 C1 CC D7 E2 ED F8
comment  2061 02A1  07 12 1D 28 33 3E 49 54 5F 6A 75 80 8B 96 A1 AC B7 C2 CD D8 E3 EE F9
comment  2061 02B8  08 13 1E 29 34 3F 4A 55 60 6B 76 81 8C 97 A2 AD B8 C3 CE D9 E4 EF FA
comment  2061 02CF  09 14 1F 2A 35 40 4B 56 61 6C 77 82 8D 98 A3 AE B9 C4 CF DA E5 F0 FB
comment  2061 02E6  0A 15 20 2B 36 41 4C 57 62 6D 78 83 8E 99 A4 AF BA C5 D0 DB E6 F1 FC
label    2064 ISR_Cols
deflabel 2065 SCREEN_COLUMNS
label    2067 ISR_Rows
deflabel 206C SCREEN_ROWS
deflabel 2076 SCREEN_ROWS
comment  2079
label    2079 Reset_Game_Select
comment  207C
comment  207C Reset game selection flashing highlights
label    2080 RGS_Flash
comment  2085
comment  2085 Setup volume and colour
comment  208A
comment  208A Disable sound object
comment  208F
comment  208F ----------------------------------------------------------
comment  208F Game Select Loop
comment  208F ----------------------------------------------------------
label    208F Game_Select
lcomment 2093 Set Port B all bits to input
lcomment 2098 Set Port A all bits to output
comment  209B
lcomment 209B Select keyboard column to read
lcomment 209D \ (F7/F5/F3/F1/CDown/CRight/Rtn/Del)
lcomment 20A0 Whilst giving keyboard data time to settle?
lcomment 20A3 Read keyboard column
lcomment 20A6 Store keyboard data
comment  20A8
comment  20A8 Test F-Keys pressed or Space to start game
lcomment 20AA F1 pressed? (1 Player)
lcomment 20AC No, skip
lcomment 20AF Reset Bit0 = 1 Player
comment  20B2
label    20B2 Test_F3
lcomment 20B4 F3 pressed? (2 Player)
lcomment 20B6 No, skip
lcomment 20B9 Set Bit0 = 2 Player
comment  20BC
label    20BC Test_F5
lcomment 20BE F5 pressed? (Keyboard)
lcomment 20C0 No, skip
lcomment 20C3 Reset Bit1 = Keyboard controls
comment  20C6
label    20C6 Test_F7
lcomment 20C8 F7 pressed? (Joystick)
lcomment 20CA No, skip
lcomment 20CD Set Bit1 = Joystick controls
comment  20D0
comment  20D0 Store options, update display and test for game start
label    20D0 Test_Space
lcomment 20D0 Save game settings
lcomment 20D1 0=1P+Kbd, 1=2P+Kbd, 2=1P+Jsk, 3=2P+Jsk
comment  20D7
lcomment 20D9 Select keyboard column to read
lcomment 20DC \ (2/Q/CBM/Space/Stop/Ctrl/Left/1)
lcomment 20DF Space Pressed?
lcomment 20E1 No, check for settings again
comment  20E3
comment  20E9
comment  20E9 ----------------------------------------------------------
comment  20E9 FUNCTION  : Init_Laser_Objects
comment  20E9 CALLED BY :
comment  20E9 CALLS     : Nothing
comment  20E9 ARGUMENTS : sentiseutn
comment  20E9 \            etinseut
comment  20E9 \            setniseutn
comment  20E9 ----------------------------------------------------------
comment  20E9 Initialise laser objects once every four calls based on IRQ counter if fire pressed
label    20E9 Init_Laser_Objects
comment  20F0
label    20F0 Init_Laser_Objects_Init
const    20F3
lcomment 20F3 ZP06/07
lcomment 20F4
word     20F4
const    20F6
comment  20F7
comment  20F7 Loop through the four possible Laser shots, branch if any are zero, i.e. first shot setup
deflabel 20F8 MAX_LASERS
deflabel 20FA LASER_TYPE_PARAM
label    20FB Loop_Update_Laser_Objects
comment  20FB
comment  20FF
comment  20FF Move 16-bit address pointer to next laser shot object i.e. 8 bytes ahead
comment  2106
comment  210C
comment  210C Test if all Laser objects updated, if yes, return, else loop back
comment  2110
comment  2110 Get Jetman state attrib i.e. fly/no-fly and facing left/right
label    2110 Init_Laser_Object
comment  2113
comment  2113 Mask for Jetman facing left/right bit and store to variable
lcomment 2113 Zero bits 0-6 x000_0000
deflabel 2114 MASK_JETMAN_DIRECTION
lcomment 2115 Set bit 4 x001_0000
binary   2116
comment  2119
comment  2119 Get Jetman Position X, manipulate bottom 3 bits and store to ZP08
lcomment 211C Zero bits 0-3 xxxx_x000
binary   211D
lcomment 211E Set bits 0 & 2 xxxx_x101
binary   211F
comment  2122
comment  2122 Test again Jetman facing left/right
deflabel 2124 MASK_JETMAN_DIRECTION
binary   2124
comment  2127
comment  2127 Jetman facing left
label    212F Init_Laser_Object_Params
comment  212F
comment  2131
comment  2131 Get Jetman Position Y, subtract some pixels to get to gun nozzle height and store to laser object
deflabel 2137 LASER_GUN_HEIGHT_OFFSET
comment  213C
comment  213C Fill Laser object parameters 2-5 with copies of X start position, but with bit 2 ANDed out
deflabel 213D LASER_POSITION_X_PARAMS
comment  2143
binary   2144
label    2145 Loop_Init_Laser
comment  2145
comment  2148
comment  214B
comment  214B Set laser shot beam length parameter 6 randomly using IRQ counter,
comment  214B range 0100_0000 to 0111_1000 i.e. $40-$78
lcomment 214E Zero bits 7,6,2-0 00xx_x000
binary   214F
lcomment 2151 Set bit 6 01xx_xx000
binary   2152
comment  2155
comment  2155 Load a random laser colour value 0-7 using IRQ counter
binary   2159
comment  2160
comment  2160 Trigger laser sound by setting parameters in sound object
comment  216B
comment  216B Green not used, it's used for the platforms only
label    216B Laser_Colour_Table
deflabel 216B COLOUR_WHITE
deflabel 216C COLOUR_RED
deflabel 216D COLOUR_CYAN
deflabel 216E COLOUR_PURPLE
deflabel 216F COLOUR_BLUE
break    216F
deflabel 2170 COLOUR_YELLOW
deflabel 2171 COLOUR_CYAN
deflabel 2172 COLOUR_YELLOW
comment  2173
comment  2173 Test if Jetman Position X is facing right at the start of a tile
label    2173 Laser_Jetman_Facing_Right
lcomment 2175 Zero bits 3-7 0000_0xxx
binary   2176
comment  2179
comment  2179 Add to the laser start Position X $18 pixels to avoid drawing laser over Jetman on screen
label    217E Laser_Jetman_Facing_Right_Wrap
comment  217E
comment  217E Test for X coordinate screen wraparound
lcomment 217E Zero bit 0 xxxx_xxx0
binary   217F
deflabel 2181 SCREEN_WIDTH_PIXELS
label    2187 Wrap_Laser_Shot_Position_X
comment  2187
comment  2187 Wrap the laser by subtracting the width of the screen in pixels from the X position
deflabel 2189 SCREEN_WIDTH_PIXELS
label    218D Add_To_Laser_Start_Position_X
comment  218D
comment  218D Add to the laser start Position X $10 pixels to avoid drawing laser over Jetman on screen
comment  2195
label    2195 Add_08
comment  219A
label    219A DISPLAY_LASERS
deflabel 219B LASER_LENGTH_PARAM
comment  21A0
comment  21A0 Y becomes $07 i.e. Laser Colour parameter
lcomment 21A0 Y=$07, laser colour addr
lcomment 21A1 Fetch laser colour
lcomment 21A3 Store to ZP variable
comment  21A5
comment  21A5 Get laser X and Y-coord and store to temp vars
deflabel 21A6 LASER_POSITION_X
comment  21AD
comment  21AD Y becomes $01 i.e. Laser Position Y
comment  21B4
comment  21B4 Test if full length of laser has now been reached, branch if yes
comment  21BB
comment  21C1
comment  21C1 Test if firing left or right
comment  21C7
comment  21C7 Add 8 if firing left or -8 if firing right ($F8 is -8)
comment  21CB
label    21CB Handle_Wrap_And_Get_Y_Cooord
lcomment 21CE Save A
deflabel 21D0 LASER_POSITION_Y
comment  21D3
comment  21D3 Register Y becomes $00 i.e. Laser Type/Direction Facing parameter
comment  21D4
comment  21D4 Laser Position Y in accumulator, test if laser shot positions near bottom of screen
comment  21D4 i.e. at or below height of fully-built rocket, branch if it is near the bottom
binary   21D5
comment  21D8
comment  21D8 Test if laser address in UDG RAM is empty, jump if not empty
comment  21D8 This stops you firing through objects when laser is above the top of the fully-built rocket
label    21DC Save_Laser_Position_X
comment  21DC
lcomment 21DC Restore A
comment  21DF
comment  21DF Reverse the displayed 8-bit byte on-screen
binary   21E2
comment  21E5
comment  21E5 Load current tile colour, check it's not green, jump if it is
lcomment 21E7 Zero top 4 bits 0000_xxxx
binary   21E8
deflabel 21EA COLOUR_GREEN
comment  21ED
comment  21ED Update laser tile colour
comment  21F1
label    21F1 Reduce_Laser_Length_Countdown
comment  21F8
comment  21F8 Test if laser length is > 7, if yes branch
lcomment 21F8 Zero bottom 3 bits xxxx_x000
binary   21F9
label    21FC UDG_RAM_Zero_Bit_2
comment  21FC
comment  21FC Probably turns of further display of laser beam
lcomment 21FE Zero bit 2 xxxx_x0xx
binary   21FF
comment  2202
comment  2202 Loads ZP 14/15/16/17 with laser decay pattern, initial laser is a line of $FF's then $03
comment  2202 subtracted leaving $FC, then $1C subtracted leaving $E0, the subtracting $E0 leaves $00
label    2202 Setup_Laser_Decay_Patterns
lcomment 2205 ZP14/15
lcomment 2206 Laser decay pattern
binary   2206-2207
break    2206
lcomment 2208 ZP16/17
lcomment 2209 Laser decay pattern
binary   2209-220A
break    2208
break    2209
lcomment 220B ZP02/03
lcomment 220C Countdown for laser params
break    220B
const    220C
word     220C
break    220C
break    220E
comment  220F
comment  220F Iterate through each of the laser shots that could be active for display
label    2211 Iterate_Laser_Params_2_3_4_5
lcomment 2216 Zero bottom 3 bits xxxx_x000
binary   2217
comment  221A
comment  221A Test if all possible laser parameters processed
comment  2221
comment  2221 All laser shots ended, set laser shots object type to zero i.e. no laser shot
deflabel 2222 LASER_TYPE_PARAM
comment  2229
comment  2229 Process laser shot, update parameters in object table
comment  2229 Get one of the four laser object paramenters, test if bit 2 is set, ef
label    2229 Process_Laser_Shot
comment  2230
comment  2230 Decrements length and test for exit condition
lcomment 2234 Zero bits 3-7 0000_0xxx
binary   2235
comment  2238
comment  2238 Use IRQ counter to add some randomness to laser decay length patterns
lcomment 223A Zero bits 2-7 0000_00xx
binary   223B
lcomment 223C Set bit 2 0000_01xx
binary   223D
comment  2242
comment  2242 Register Y is 3 or 4 or 5 or 5 at this point, thus setting bit in laser x-coords
lcomment 2244 Set bit 2 xxxx_x1xx
binary   2245
comment  2248
label    2248 Update_Obj_Params_And_Exit
deflabel 2249 LASER_LENGTH_PARAM
comment  224E
deflabel 224F LASER_POSITION_X
comment  2254
comment  2257
comment  2257 Get X-coord from object list parameters and Y-coord, store to UDG RAM address pointers
comment  2257 and increment/decrement by 8 depending on firing left or right
label    2257 Update_Laser_Position_X
comment  225E
comment  225E Add 8 if firing left or -8 if firing right ($F8 is -8)
comment  2263
label    2263 Account_For_Wraparound
comment  2268
comment  226C
comment  226C EXOR-write data in ZP variable to UDG RAM
comment  226E
comment  2274
comment  2274 Apply laser decay pattern onto screen
comment  227C
comment  227E
label    2285 ADC_08_
label    228B Cascade_Laser_Pattern_Data
comment  228B
comment  2285
comment  2298
comment  2298 Looks like it's doing some checks on the X coord, e.g. laser wraparound
label    2298 Laser_Wrap
lcomment 2299 Zero bits 0-2 xxxx_x000
binary   229A
deflabel 229C SCREEN_WIDTH_PIXELS
label    22A1 Laser_Wrap_Left_To_Right
comment  22A1
comment  22A3
comment  22A3 Test top bit i.e. direction left or right
deflabel 22A4 LASER_TYPE_PARAM
comment  22AC
comment  22AE
comment  22AE Change X position from e.g. $FD to $B5, where $B8 is screen width in pixels
lcomment 22AF Zero bits 3-7 0000_0xxx
binary   22B0
lcomment 22B1 Set bits 7,5,4 1011_0xxx
binary   22B2
comment  22B4
label    22B4 Laser_Wrap_Right_To_Left
comment  22B6
comment  22B6 Change X position to become left side of screen (between 0 and 7)
lcomment 22B7 Zero bits 3-7 0000_0xxx
binary   22B8
comment  22BA
label    22BA Reset_Level_Add_Extra_Life
comment  22BD
comment  22BD When wave number ends in %11, add extra life e.g. 4th wave, 8th wave etc.
lcomment 22BF Reset bits 2-7 0000_00xx
binary   22C0
comment  22C3
comment  22C3 Add extra life
label    22CB Draw_Platforms_Init_Sound
comment  22CB
comment  22D1
label    22D1 Restore_Player_Objs_Init_Sound
comment  22D7
label    22D7 Reset_Level
comment  22E3
comment  22E3
comment  22E3
comment  22E3
comment  22E3
label    22E3 Set_Obj_Rocket_Top_Or_Fuel_Typ
lcomment 22E9 ZP00/01
word     22EA
label    22ED Reset_Object
break    22ED
comment  22ED
comment  22F2
label    22F2 Set_Obj_Rocket_Mid_Or_Valu_Typ
word     22F9
label    22FF Reset_Rocket_Obj_Params
comment  22FF
comment  22FF
comment  22FF
comment  22FF
comment  22FF
comment  22FF Init rocket top, middle and bottom object parameters (i.e. 3 x 8 bytes) from static data table
label    2301 Loop_Reset_Rocket_Obj_Params
comment  2301
label    230B Reset_Rocket_Obj_Params_Init
comment  230B
word     2315
label    231A Loop_Reset_Objects
comment  231A
comment  2318
comment  2318 Reset rocket top, middle and bottom
comment  231C
comment  2325
comment  2325 Move 16-bit address pointer to next object i.e. 8 bytes ahead
comment  232C
comment  2332
comment  2334
comment  2337
label    233B Init_Rocket_Objs_Param_Table
lcomment 233B $09=Rocket Bottom Section, Posn_X, ?, Posn_Y
const    233B-235A
comment  233B
lcomment 233F $01=Pickup Status, ?, Height on Landing, ?
break    233F
comment  2343
lcomment 2343 $04=Rocket Top Section
break    2343
break    2347
comment  234B
lcomment 234B $04=Rocket Middle Section
break    234F
comment  2353
label    2353 Init_Jetman_Obj_Param_Table
lcomment 2353 State, Posn_X, Dir_X, Posn_Y
lcomment 2357 Dir_Y, ?, ?, ?
break    2357
comment  235B
label    235B Init_Next_Jetman_Lives_Scores
comment  235B Reset Jetman object parameters (i.e. 1 x 8 bytes) from static data table
label    235D Loop_Init_Jetman_Obj
comment  235D
comment  2366
comment  2366 Test if two player game, if yes, give $FF time between players for switchover instead of $7F
binary   236A
label    236F LDA_7F_Return
comment  236F
comment  2373
label    2373 Display_Player_1_Lives
lcomment 2376 ZP04/05
const    2376
word     2377
comment  237A
comment  237A Display number of lives, or erase from screen if zero
comment  2382
label    2382 Display_Player_2_Lives
lcomment 2385 ZP04/05
const    2385
word     2386
comment  2389
comment  2389 Display number of lives, or erase from screen if zero
comment  238E
label    238E Display_Number_Of_Lives
lcomment 238F $70 = "0" character
deflabel 2390 CHARACTER_ZERO
comment  2396
comment  2396 Display Jetman Icon next to number of lives
lcomment 2399 ZP06/07
word     239A
comment  239D
comment  239D Jetman UDG has 8 bytes of data to copy
label    23A2 Erase_Player_1_Lives
comment  23A2
comment  23A8
label    23A8 Erase_Player_Lives
deflabel 23A9 CHARACTER_SPACE
lcomment 23A8 $60 = Space character
lcomment 23AF $60 = Space character
comment  23AF
deflabel 23B0 CHARACTER_SPACE
comment  23B6
label    23B6 Load_Player_1_Lives
comment  23BA
label    23BA Load_Player_Active_Lives
label    23BD Load_Player_Inactive_Lives
comment  23BD
label    23C0 Load_Player_2_Lives
comment  23C0
label    23C7 Jetman_Icon_UDG_Char_Data
comment  23C7
lcomment 23C7 \...##...
const    23C7-23CE
bin      23C7-23CE
break    23C7-23CE
lcomment 23C8 \..#..#..
lcomment 23C9 \..####..
lcomment 23CA \.######.
lcomment 23CB \.#.##.#.
lcomment 23CC \..####..
lcomment 23CD \..####..
lcomment 23CE \.##..##.
comment  23CF
label    23CF LDA_7F
comment  23D4
comment  23D4
comment  23D4
comment  23D4
comment  23D4
comment  23D4 Set Active Player, initial lives for both players and Rocket object parameters
label    23D4 Setup_Player_Lives
label    23D6 Loop_Setup_Player_Lives
comment  23D6
deflabel 23D7 PLAYER_1
comment  23DA
deflabel 23DB LIVES_INITIAL_PLAYER_1
comment  23DE
comment  23E1
comment  23E7
deflabel 23E8 LIVES_INITIAL_PLAYER_2
comment  23EB
comment  23EB Test if single player game, if yes, set Player 2 lives to 0 i.e. inactive player
binary   23EF
label    23F4 Setup_Player_Lives_RTS
comment  23F4
label    23F5 Swap_Player_And_Obj_Rocket
comment  23F5
comment  23F5 When active player changes, swap current active/inactive player wave and rocket object data
label    23F7 Swap_Player
comment  23F9
comment  23FF
comment  2404
label    2406 Loop_Swap_Rocket_Object
comment  2406
comment  2409
comment  2410
comment  2416
label    2416 Reset_Screen_Display_Scores
comment  2425
comment  2425 Three strings to display across top of screen, 1UP, HI and 2UP
label    2425 Display_1UP_HI_2UP_Text
label    2429 Loop_Display_1UP_HI_2UP_Text
comment  2429
comment  242F
comment  2435
comment  243B
comment  2441
comment  244C
label    2450 STR_1UP
comment  2450
deflabel 2450 COLOUR_WHITE
lcomment  2451 `=Space, q=1, r=2
lcomment 2456 Top bit=1 indicates end of string
label    2457 STR_HI
break    2457
deflabel 2457 COLOUR_YELLOW
label    245E STR_2UP
break    245E
deflabel 245E COLOUR_WHITE
comment  2465
label    2465 STR_1UP_HI_2UP
lcomment 2465 X Y
word     2467
lcomment 2469 X Y
const    2469
word     246B
lcomment 246D X Y
word     246F
comment  2471
label    2471 Display_Player_1_Score
lcomment 2474 ZP04/05
lcomment 2475 UDG RAM address to display score at
word     2475
lcomment 2477 ZP0E/0F
lcomment 2478 Players score BCD e.g. 12 34 56
word     2478
lcomment 247A ZP02/03
lcomment 247B 3 bytes of BCD data to display e.g. 12 34 56
word     247B
const    247B
label    2481 Display_Player_2_Score
comment  2481
const    2484
word     2485
const    2487
word     2488
const    248A
word     248B
const    248B
break    248D
label    2491 Display_High_Score
comment  2491
const    2494
word     2495
const    2497
word     2498
const    249A
word     249B
const    249B
break    249D
label    24A1 Game_Select_Flash
comment  24A1
comment  24A1 Update the selected option flashing text status i.e. option selected and display yes/no
comment  24A1 Register A enters with bit 0 set as Players 1 or 2, or Joystick or Keyboard
comment  24A1 Register X enters as 0 or 2, which is an index into the Game Select Fn Key status
comment  24A1 Code runs twice, first with JSR/RTS, then with normal run though, ending with RTS
label    24A4 Game_Select_Flash_1
comment  24A4
comment  24A5
comment  24A5 Test setting flag, if set, this is the unselcted option, skip the countup/invert part
binary   24A6
comment  24A9
comment  24A9 This is the selected option, divide the counter by 8 and use it to set the display
comment  24A9 selected on/off flag i.e. periodically flash it at about 2Hz
comment  24AE
comment  24AE Convert the counter value into a display on/off flag toggle
comment  24AE Set bit 7 to make this selected option flash
binary   24AF
binary   24B1
label    24B2 Store_Option_Selection_State
comment  24B2
binary   24B6
comment  24B5
comment  24B5 Invert Register A bit 0, increment the Game Select Fn Key index and loop back (or RTS)
comment  24B9
comment  24BB
comment  24BB Set selected game options for 1 or 2 Player (Game_Settings bit 0)
label    24B9 Display_Game_Select
binary   24BF
comment  24C3
comment  24C3 Set selected game options for Joystick or Keyboard (Game_Settings bit 1)

comment  24CA
lcomment 24CD ZP04/05
lcomment 24CE X Y
break    24CE
const    24CF
break    24D0
lcomment 24D0 ZP0E/0F
word     24D1
comment  24D7
lcomment 24DA ZP04/05
lcomment 24DB X Y
break    24DB
break    24DD
lcomment 24DD ZP0E/0F
word     24DE
comment  24E4
lcomment 24E7 ZP0E/0F
word     24E8
comment  24EB
comment  24EB Setup and display attract screen game selection options
label    24EF Loop_Display_Game_Select
comment  24EF
comment  24EF X position is hardcoded, Y position comes from a lookup table keyed on ZP08 Index
deflabel 24F0 TEXT_POSITION_X
comment  24F3
comment  24FA
comment  2500
comment  2500 Setup and call string display routine
comment  2509
comment  2509 Display_String increments the Y register by number of characters displayed, now increment
comment  2509 it again and add it to 16-bit address of the next string to display in ZP0E/0F
comment  2510
comment  2516
comment  2516 Increment table index and test if all rows displayed
deflabel 251B OPTION_TEXT_ROWS
comment  251F
label    251F Fn_And_SP_Row_Offsets
const    251F-2523
comment  2524
label    2524 STRING_COPYRIGHT_1983_ACG
lcomment 2539 Bit 7 = 1 indicates string end, $EE = $6E + bit 7
lcomment 2539 `= Space, qyxs = 1983, n=.
label    253A STRING_JETPAC_GAME_SELECT
lcomment 254F $CE = $4E + top bit, $4E = "N"
label    2550 STRING_F1_1_PLAYER_GAME
label    2562 STRING_F3_2_PLAYER_GAME
label    2574 STRING_F5_KEYBOARD
label    2581 STRING_F7_JOYSTICK
label    258E STRING_SP_START_GAME
comment  259D
label    259D Load_ZP_Parameters
comment  259D Parameters for this routine are assembled into memory directly after the
comment  259D call to this routine. When the routine is called using JSR, the return address
comment  259D will be the address of the first parameter, so they can be pulled off using PLA.
comment  259D First two stack values are the 16-bit address where next two stack values will be stored.
comment  25A3
label    25A5 Loop_Test_Param_List_End
comment  25A5
comment  25A5 $FF signifies end of address/parameter data to load
comment  25AB
comment  25AB All parameters now loaded, push a new return address back onto the stack and RTS
label    25B5 Load_ZP_Parameter
comment  25B5
comment  25B5 Register A contain 8-bit ZP address to store 16-bit value to, Register Y is 1
comment  25B6
comment  25B6 Increment the param address, load the data stored there and store it to a ZP location
comment  25BD
comment  25BD Inc the param address again, load the data stored there and store it to a ZP location
comment  25C4
comment  25C4 Inc the param address again and loop back to process next data value
label    25CA Inc_Param_Addr
comment  25CA
comment  25CA Increment the 16-bit parameter address, lo-byte then hi-byte if necessary
comment  25D0
label    25D0 Inc_Param_Addr_RTS
comment  25D1
label    25D1 Game_Start
comment  25E0
comment  25E0 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     25E0 Hardware_Interrupt_Handler
comment  25E2
comment  25E2 Set IRQ Occured flag, used to prioritise Jetman object handling in main loop
comment  25E4
comment  25E4 Reset VIA2 timer, which directly regulates Jetman's update speed
comment  25E7
comment  25E7 Use TV Raster value as a pseudo-random number generator
comment  25EE
comment  25EE Increment 16-bit counter
comment  25F4
label    25F4 Restore_Registers_And_RTI
comment  25FA
comment  25FA ----------------------------------------------------------
comment  25FA Game Main Loop
comment  25FA ----------------------------------------------------------
label    25FA Main_Loop_Init
comment  25FE
comment  25FE Reset object list index to $03B0 i.e. Rocket Ascend/Decend
comment  2606
comment  2606 Enable Interrupts (Clear Interrupt Disable)
comment  2607
label    2607 Main_Loop
comment  2609
comment  2609 Load Object Type into A from object table, multiply by two for address jump table index use
comment  260C
comment  260C Setup subroutine address from jump table + index and indirect jmp to it
comment  261A
label    261A GOTO_NEXT_OBJECT
comment  261C
comment  261C Test next object type, if non-zero, skip to next object
comment  2620
comment  2620 Test if current object address is Jetman, a laser beam, the sound object or zero, branch if yes
deflabel 2623 OBJECT_ROCKET_ADDRESS
comment  2626
comment  2626 Current object is a rocket part or an Alien
comment  2626 Delay loop, adjusting Register Y from $02 to $0F makes aliens move ~40% slower across screen
comment  2626 $100 x $02 x (2+3 cycles) = $A00 = 2,560 cycles @ 1.108MHz PAL = 0.02 Seconds
comment  262A
label    262A Loop_Delay_0A00_Cycles
comment  2630
comment  2630 Increment Object Pointer to next Obj i.e. by adding 8 bytes
label    2630 Inc_Object_List_Ptr
comment  2637
comment  2637 If interrupt had occurred, set Jetman object next, it has higher priority
comment  263B
comment  263B Test if current object is Jetman, a laser beam, the sound object or zero, branch if not
label    263B Main_Loop_Continue
deflabel 263E OBJECT_ROCKET_ADDRESS
comment  2641
comment  2641 Current object is Jetman, a laser beam or the sound object
comment  2641 Test if current object addres lo-byte is zero, i.e. starting at beginning of list, branch if not
comment  2645
comment  2645 Test to see if Spawn counter has reached four yet, branch if not
comment  264B
comment  264B Test TV Raster counter, spawn object ever eight attepts i.e. when data = xxxx_x111
binary   264F
comment  2652
comment  2652 Test if score flash time is zero, if yes, reset next object pointer and spawn setup objects
label    2652 Test_Score_Flash_Time_At_Zero
comment  2655
label    2655 Spawn_Objects
comment  265E
comment  265E ----------------------------------------------------------
comment  265E VIA2 timer interrupts used to update Jetman movement
comment  265E $4FD7 / 1.108Mhz = 54.2Hz interrupt. Screen is 184 pixels
comment  265E wide. At one pixel walking movement per interrupt, Jetman
comment  265E should get across the screen in about 3.5 seconds.
comment  265E ----------------------------------------------------------
label    265E Reset_VIA2_Timer
comment  2669
comment  2669 Disable Interrupts (Set Interupt Disable)
comment  2669 Save current object list pointer and set Jetman to be the next object
label    2669 SEI_Obj_Ptr_To_Jetman
comment  266A
comment  266E
comment  266E Save the current object list ptr and load up the Jetman object parameters
comment  2676
comment  2676 Load Jetman object parameters
lcomment 2679 ZP00/01
const    2679
word     267A
comment  2680
comment  2680
label    2680 Restore_Saved_Obj_Ptr_And_CLI
comment  2688
comment  2688 Enable Interrupts (Clear Disable Interrupts)
comment  268C
label    268C Subroutine_List
lcomment 268C 00
word     268C-26AD
label    268D Subroutine_List+1
lcomment 268E 01
lcomment 2690 02
lcomment 2692 03
lcomment 2694 04
lcomment 2696 05
lcomment 2698 06
lcomment 269A 07
lcomment 269C 08
lcomment 269E 09
lcomment 26A0 0A
lcomment 26A2 0B
lcomment 26A4 0C
lcomment 26A6 0D
lcomment 26A8 0E
lcomment 26AA 0F
lcomment 26AC 10
comment  26AE
comment  26AE Init sound object parameters (i.e. 8 bytes) from static data table
label    26AE Initialize_Sound_Object
comment  26B0
label    26B0 Loop_Initialize_Sound_Object
comment  26B9
comment  26B9 Initialize sound channels
comment  26C5
label    26C5 Init_Sound_Object_Table
break    26C9
comment  26CD
comment  26CD Read and play sound channel data from the Sound object
label    26CD SOUND_UPDATE
comment  26D1
comment  26D1 Sound object parameter 01/03/05 indicates which sound to play, 02/04/06 is the period
label    26D1 Loop_Sound_Update
comment  26D7
comment  26D7 Jump to Sound player using Register X as jump table index
comment  26E4
comment  26E4 Update index to next 2-byte oscillator/timer pair, stopping when
comment  26E4 all 3 processed i.e. at 7th parameter. Sound 0 is valid
comment  26E4 but 'empty' sound call, so just moves to next 2-byte oscillator/timer pair.
label    26E4 Goto_Next_Sound
deflabel 26E8 WORD_SIZE
comment  26F2
comment  26F2 Decrements Oscillator channel timer stored in ZP index
comment  26F2 Index points to Oscillator number, so increment to address timer value
comment  26F2 Timer value left in A, counts down to zero
label    26F2 Decrement_Oscillator_Timer
comment  26F6
comment  26F6 Read timer, decrement and write back
comment  26FE
label    26FE Rocket_Part_or_Fuel_Cell_Pickup
comment  2703
comment  2703 Reverses the timer value so $10 countdown becomes $F0, F1, F2 etc. stored
comment  2703 to the oscillator on subsequent calls, making a pleasent short rising tone
binary   2704
comment  2705
comment  2705 Set top bit of oscillator channel to enable
label    2705 Enable_Oscillator_Channel
binary   2706
comment  270A
comment  270A When oscillator timer expired, delete the oscillator parameter to disable
label    270A Sound_Done_Reset_Object_Param
comment  2710
comment  2710 Register A contains frequency, Y selects channel via X
label    2710 Output_Sound
comment  2716
comment  271C
label    271C Valuable_Pkup_Rocket_Part_Land
comment  2721
comment  2721 Manipulate timer to make a nice sound
binary   2723
comment  2727
label    2727 Laser_Beam_Active
comment  272C
comment  272C Manipulate timer to make a nice sound
binary   2731
comment  2735
label    2735 Rocket_Flight
comment  273A
comment  273A Utilise rocket object height to manipulate noise sound channel
binary   273F
comment  2743
label    2743 Subroutine_Sound_Jump_Table
lcomment 2743 00
word     2743-274D
label    2744 Subroutine_Sound_Jump_Table+1
lcomment 2745 01
lcomment 2747 02
lcomment 2749 03
lcomment 274B 04
lcomment 274D 05
comment  274F
label    274F Collision_Explosion
comment  2754
comment  2754 Manipulate timer to make an explosion sound, though doesn't use noise
binary   2757
comment  275B
comment  275B Erase $100 bytes Zero Page RAM
label    275B Erase_ZP_RAM
comment  275E
label    275E Loop_Erase_ZP_RAM
comment  2764
comment  2764 Erase $80 bytes Object RAM
label    2764 Erase_Object_RAM
comment  2768
label    2768 Loop_Erase_Object_RAM
comment  276F
comment  276F Erase $30 bytes High Score & Game Settings at $1FD0-$2000
label    276F Erase_Hi_Score_Game_Settings
comment  2773
label    2773 Loop_Erase_Hi_Score_Game_Sets
comment  277A
label    277A Check_New_Hi_Score
lcomment 277D ZP00
const    277D
lcomment 277E Hi Score value addr
word     277E
lcomment 2780 ZP08
const    2780
lcomment 2781 Player 1 Score value addr
word     2781
comment  2784
comment  2784 Check Player 1 first
comment  2787
comment 2787 \...then follow through for Player 2
lcomment 278A ZP08
const    278A
lcomment 278B Player 2 Score value addr
word     278B
comment  278E
comment  278E Compare Hi Score BCD bytes
label    278E Test_New_Hi_Score
comment  2790
label    2790 Compare_BCD_Byte
comment  2796
comment  2796 Branch if Player Score > Score_Hi
comment  2798
comment  2798 Score_Hi >= Player Score, so return
comment  2799
comment  2799 Test if all 3 BCD bytes have been compared, if not loop to next BDC byte
label    2799 Move_To_Next_BCD_Byte
comment  27A0
label    27A0 Copy_Player_Score_To_Hi_Score
comment  27A0 Player score is 3 BCD bytes
comment  27A2
label    27A2 Loop_Copy_Player_To_Hi_Score
lcomment 27A7 Return when all bytes copied
comment  27AA
label    27AA Display_Rocket_Flame
deflabel 27AB OBJECT_TYPE_PARAM
deflabel 27AF OBJECT_TYPE_ROCKET_ASCEND
comment  27B0
comment  27B0 Carry set if memory less than value in Register A, meaning branch on Ascend and Decend
comment  27B3
label    27B3 Display_Rocket_Flame_Asc_Desc
comment  27B5
comment  27BD
comment  27C5
comment  27C5 On ascend, BCS followed each time until Flame Space Available, which triggers Display_Flame
comment  27C5 once, after that, both branches fail. Descend is similar.
deflabel 27C6 FLAME_SPACE_AVAILABLE
comment  27CB
comment  27CB Rocket flame should now be on, if yes, display it
comment  27CF
comment  27CF If flame not yet on, i.e. first time round, turn the flame status on
comment  27D3
comment  27D3 Load the correct Flame UDG address and display the flame
comment  27E1
label    27E1 Display_Rocket_Flame_On_Screen
comment  27EA
comment  27EA Load the correct Flame UDG address and display the flame
comment  27F7
comment  27F7 Set the flame colour tile to red, uses two tiles
comment  27FB
comment  27FF
deflabel 2803 COLOUR_RED
comment  2808
comment  280B
comment  280B Restore ZP11 and ZP19 and return
label    280B Restore_And_RTS
comment  2812
label    2812 Set_Rocket_Flame_Status_Off
comment  2819
comment  2819 Display flame if flame state is on, else return
label    2819 Display_Flame
comment  281D
comment  282E
comment  282E Using A to toggle, Load A and Y with Ship UDG address
comment  282E LSR and AND make the toggle only happen every 4 calls so you can see it on-screen
label    282E Get_Flame_UDG_Addr
binary   2830
comment  283A
comment  283A Flame animation is produced by toggling between two animation frames
label    283A Ptr_Rocket_Flame_Frame_0_Lo
const    283A-283d
label    283B Ptr_Rocket_Flame_Frame_0_Hi
label    283C Ptr_Rocket_Flame_Frame_1_Lo
label    283D Ptr_Rocket_Flame_Frame_1_Hi
comment  283E
comment  283E Remove "Test_Platform_Collision"=Gems all fall through platforms and floor, reentering at top
label    283E VALUABLES
comment  2848
comment  2848 Move valuable Y position down screen by 2 pixels
deflabel 2849 OBJECT_POSITION_Y_PARAM
comment  2851
label    2851 Valuable_Landed
comment  2859
comment  2859 Object has been picked-up, remove from screen. S F V = Ship Fuel Valuable
comment  2867
comment  2867 Jetman pickup valuable = 250 points, then remove from object list
lcomment 286A ZP02/03
word     286B
const    286B
break    286D
comment  2874
deflabel 2875 OBJECT_VALUABLE_TYPE_PARAM
binary   2879
comment  287A
label    2874 Animate_Valuable
comment  287A Use valuable type to index into subroutine list and jump to subroutine
comment  2880
comment  2888
label    2888 Subroutine_List_Valuables
word     2888-2891
break    2888-2891
label    2889 Subroutine_List_Valuables+1
comment  2892
label    2892 Valuable_Gold_Bar
deflabel 2893 COLOUR_YELLOW
comment  2894
label    2894 Save_Colour_And_Display_Object
deflabel 2895 OBJECT_COLOUR_PARAM
comment  2898
deflabel 2899 OBJECT_VALUABLE_TYPE_PARAM
label    289F Valuable_Mineral
comment  289F
deflabel 28A0 COLOUR_BLUE
comment  28A4
comment  28A4 Use IRQ counter to toggle object colour between black and cyan
label    28A4 Valuable_Plutonium
binary   28A7
binary   28A9
comment  28AC
deflabel 28AD COLOUR_BLACK
comment  28B1
label    28B1 Valuable_Plutonium_Set_Colour
deflabel 28B2 COLOUR_CYAN
comment  28B6
comment  28B6 Use IRQ counter to cycle through colours, two LSRs quadruple the time between changes
label    28B6 Valuable_Gemstone
binary   28BB
comment  28BE
comment  28BE Change colour from black to white
binary   28BF
comment  28C0
comment  28C0 If new colour is green, change it to white, green is reserved for platform logic
label    28C0 Valuable_Gemstone_Set_Colour
deflabel 28C1 COLOUR_GREEN
deflabel 28C5 COLOUR_WHITE
comment  28C9
comment  28C9 Reset rocket parts/fuel/valuables and alien objects, $47 is 9 objects data
label    28C9 Reset_Objects_And_Aliens
comment  28CD
label    28CD Loop_Reset_Objects_And_Aliens
comment  28D4
comment  28D4 Reset Jetman, Lasers, Sounds, Rocket and Aliens, $2F is 6 objects data
label    28D4 Reset_Objects_Multiple
comment  28D8
label    28D8 Loop_Reset_Objects_Multiple
comment  28DE
comment  28DE Init all Alien objects
comment  28E0
label    28E0 Loop_Reset_Objects_Aliens
comment  28E7
comment  28E7 General save and restore of object list pointer, not used as part of interrupt handler
label    28E7 Save_Obj_List_Ptr
comment  28F0
label    28F0 Restore_Obj_List_Ptr
comment  28F9
label    28F9 Change_Object_To_Explosion
comment  28FC
comment  28FC Reset object X direction
deflabel 28FF OBJECT_DIRECTION_X_PARAM
comment  2902
comment  2902 Get object type, zero middle four bits, preserve bits 6 and 7, set bits 1 & 2
comment  2902 The AND and OR probably for jetman object
deflabel 2903 OBJECT_TYPE_PARAM
lcomment 2906 Zero bits 0-5 xx000000
binary   2907
lcomment 2908 Set bits 0-1 xx000011
binary   2909
comment  290A
label    290A Set_Object_Type_To_Explosion
deflabel 290B OBJECT_TYPE_PARAM_SAVED
comment  290E
comment  290E Change object type to an explosion
deflabel 290F OBJECT_TYPE_PARAM
deflabel 2911 OBJECT_TYPE_EXPLOSION
comment  2914
comment  2914 Use parameter as animation frame counter, now reset it
deflabel 2916 EXPLOSION_ANIMATION_FRAME
comment  2919
comment  2919 Change explosion object colour based on IRQ random generator
lcomment 291B Zero bits 3-8 00000xxx
binary   291C
lcomment 291F Set bit 0 xxxxxxx1
comment  291F
comment  291F Colour is black, bump it to white by incrementing
deflabel 2920 COLOUR_WHITE
label    2921 Test_New_Colour_Is_Green
comment  2921
deflabel 2922 COLOUR_GREEN
lcomment 2925 Colour code
comment  2925
comment  2925 If colour is green, bump to Blue, Green only used for platforms
deflabel 2926 COLOUR_BLUE
comment  2927
label    2927 Store_Updated_Explosion_Colour
deflabel 2928 OBJECT_COLOUR_PARAM
comment  292B
comment  292B Trigger explosion sound (noise + regular oscillator)
comment  2934
comment  2934 If an alien explosion occurs, add a new alien
label    2934 ANIMATE_EXPLOSIONS
comment  2939
comment  2939 Appears to add randomness to how long an animation frame is displayed using the IRQ counter
comment  2939 Param 02 of alien object is always set to zero, for Jetman is always set to one
comment  2941
comment  2941 Increment explosion animation frame count
deflabel 2942 EXPLOSION_ANIMATION_FRAME
comment  294A
label    294A Test_Explosion_Animation_Done
deflabel 294B EXPLOSION_ANIMATION_FRAME
deflabel 294F EXPLOSION_ANIMATION_FRAMES
comment  2952
comment  2952 Setup Registers A and Y to point to the correct explosion UDG data
comment  295B
comment  295B Update the explosion on screen
comment  2967
label    2967 Explosion_UDG_RAM_Addr_Table
word     2967-2974
label    2968 Explosion_UDG_RAM_Addr_Table+1
break    2969
break    296E
comment  2975
comment  2975 Disable explosion object by setting object type to zero
label    2975 Disable_Explosion_Obj_In_List
deflabel 2976 OBJECT_TYPE_PARAM
comment  297A
comment  297A Test if object was an Alien or Jetman, branch if Jetman
deflabel 297B OBJECT_TYPE_PARAM_SAVED
binary   297F
binary   2981
comment  2984
comment  2987
label    2987 Game_Over
comment  2991
comment  2991 Game Over Player 1
comment  2997
label    2997 Game_Over_Player_2
comment  299D
label    299D Reset_Objects_Test_Game_Over
comment  29AB
comment  29AB Unset "Picked-up by Jetman"
binary   29AF
comment  29B3
comment  29B3 Unset "Picked-up by Jetman"
binary   29B7
comment  29BB
comment  29BB Test if 1 or 2 Player Game, branch if 2 Player
comment  29C3
label    29C3 Test_Game_Over_Active_Player
comment  29C7
label    29C7 Reset_Level_Init_Next_Jetman
comment  29D0
label    29D0 Test_Game_Over_Inactive_Player
comment  29D4
comment  29D4 Test Game Over Active Player, if not swap to other players data
comment  29D8
comment  29DB
label    29DB Swap_Active_Player_And_Objects
binary   29E1
comment  29E7
label    29E7 Display_Game_Over
comment  29EE
label    29EE Display_Game_Over_Player_1
lcomment 29F1 ZP0E/0F
word     29F2
lcomment 29F4 ZP04/05
lcomment 29F5 X Y
const    29F6
break    29F7
comment  29F8
label    29F8 Display_Game_Over_Player_1_2
comment  29FB
comment  29FB Setup Game Over Delay Loop
lcomment 29FE ZP02/03
word     29FF
const    29FF
lcomment 2A01 ZP0A/0B
word     2A02
const    2A02
comment  2A05
comment  2A05 Wait a few seconds when Game Over is displayed on screen
comment  2A05 Delay loop $100^2 x ($100-$F8=$08) x (5+3=$08) = $400,000
comment  2A05 \                                           = 4,194,304 cycles @ 1.108MHz PAL
comment  2A05 \                                           = 3.785 Seconds
label    2A05 Delay_Loop_Game_Over
lcomment 2A05 5 cycles
lcomment 2A07 3 cycles when taken, 2 when not taken
comment  2A12
label    2A12 Display_Game_Over_Player_2
lcomment 2A15 ZP0E/0F
word     2A16
lcomment 2A18 ZP04/05
const    2A18
lcomment 2A19 X Y
const    2A1A
break    2A1B
comment  2A1F
label    2A1F STR_GAME_OVER_PLAYER_1
comment  2A32
label    2A32 STR_GAME_OVER_PLAYER_2
break    2A32
comment  2A45
comment  2A45 Jetman has collided with an alien, setup object ready to become an explosion
label    2A45 Setup_Jetman_Explosion
word     2A4C
comment  2A4F
comment  2A4F Reset Jetman direction parameter, i.e. stop moving
deflabel 2A50 OBJECT_JETMAN_DIRECTION_PARAM
comment  2A55
comment  2A55 Save object type and then change it to an explosion
comment  2A5F
label    2A5F WAVE_1_CROSS
comment  2A67
comment  2A67 Alien not hit by laser, check to see if hit platform, aliens bounce off after first wave, so
comment  2A67 update direction
label    2A67 Wave_1_Cross_Direction_Update
comment  2A6D
label    2A6D WAVE_2_SPHERE
comment  2A75
comment  2A75 Alien not hit by laser, check to see if hit platform, aliens bounce off after wave 0
comment  2A75 so update direction
label    2A75 Wave_2_Sphere_Direction_Update
comment  2A78
comment  2A78 Read direction Y reversal countdown, branch if zero, else decrement countdown
deflabel 2A79 OBJECT_DIR_Y_COUNTDOWN_PARAM
comment  2A83
comment  2A83
comment  2A83
comment  2A83
comment  2A83 Below routine common to waves 1 and 2
label    2A83 Direction_X_Y_Update
deflabel 2A84 OBJECT_DIRECTION_X_PARAM
deflabel 2A8A DIRECTION_X_RIGHT
comment  2A8B
label    2A8B Direction_X_Store_
comment  2A8D
comment  2A8D Direction_Y_Update
deflabel 2A8E OBJECT_DIRECTION_Y_PARAM
deflabel 2A94 DIRECTION_Y_DOWN
comment  2A95
label    2A95 Direction_Y_Store_
comment  2A9A
label    2A9A Load_Direction_Y_Up
deflabel 2A9B DIRECTION_Y_UP
comment  2A9E
label    2A9E Load_Direction_X_Left
deflabel 2A9F DIRECTION_X_LEFT
comment  2AA2
comment  2AA2 Reset random direction Y change countdown initial value using IRQ random number, range $10-$1F
label    2AA2 Direction_Y_Update_Rand
binary   2AA5
binary   2AA7
comment  2AAA
comment  2AAA Reverse direction Y up/down, randomly via IRQ random number, bit 2
deflabel 2AAB OBJECT_DIRECTION_Y_PARAM
binary   2AAD
comment  2AB2
comment  2AB2 Invert on the direction byte
binary   2AB3
comment  2AB7
label    2AB7 Direction_Y_Store_Rand
comment  2ABC
label    2ABC WAVE_3_SAUCER
comment  2AC4
comment  2AC4 Alien not hit by laser, check to see if hit platform, aliens bounce off after wave 0 so
comment  2AC4 update direction
label    2AC4 Wave_3_Saucer_Direction_Update
comment  2AC7
comment  2AC7 Saucers home-in on Jetman, thus below code is in four sections:
comment  2AC7 - Two sections update X depending on whether alien is left or right of Jetman
comment  2AC7 - Two sections update Y depending on whether alien is above or below Jetman
comment  2AC7
comment  2AC7 Direction X Update
deflabel 2AC8 OBJECT_POSITION_X_PARAM
comment  2ACB
comment  2ACB Register Y becomes offset to Object Direction X parameter
comment  2ACC
comment  2ACC Compare alien and jetman positions, branch if alien to left of jetman
comment  2AD2
comment  2AD2 Alien is to the right of Jetman
comment  2AD2 Test if alien moving right, if yes, immediately decrement the direction i.e. so it moves left
comment  2AD7
comment  2AD7 Test Direction X, when $FC reached, movement left speed is maxed out, go straight to Y update
deflabel 2AD8 DIRECTION_X_LEFT_MAX
comment  2ADB
comment  2ADB Decrement alien direction X i.e. so it moves left
label    2ADB Direction_X_Decr
comment  2ADD
comment  2ADD Store new direction X back to alien object
label    2ADD Direction_X_Store
comment  2ADF
comment  2ADF
comment  2ADF Alien Direction Y Update, same logic as Direction X Update
label    2ADF Position_Y_Update
deflabel 2AE0 OBJECT_POSITION_Y_PARAM
comment  2AE3
comment  2AE3 Register Y becomes offset to Object Direction Y parameter
comment  2AE4
comment  2AE4 Compare alien and jetman positions, branch if alien is above jetman
comment  2AEA
comment  2AEA Alien is below Jetman
comment  2AEA Test if alien moving down, if yes, immediately decrement the direction i.e. so it moves up
comment  2AEF
comment  2AEF Test Direction Y, when $FC reached, movement up speed is maxed out, exit direction update routine
deflabel 2AF0 DIRECTION_Y_UP_MAX
comment  2AF3
comment  2AF3 Decrement alien direction Y i.e. so it moves up
label    2AF3 Direction_Y_Decr
comment  2AF5
comment  2AF5 Store new direction Y back to alien object
label    2AF5 Direction_Y_Store
comment  2AF7
label    2AF7 Wave_3_Saucer_Exit
comment  2AFA
comment  2AFA Alien to left of Jetman, increment alien direction X by one until max reached
label    2AFA Direction_X_Increment
deflabel 2B00 DIRECTION_X_RIGHT_MAX
comment  2B03
label    2B03 Direction_X_Inc
comment  2B08
comment  2B08 Alien is below Jetman, increment alien direction Y by one until max reached
label    2B08 Direction_Y_Increment
deflabel 2B0E DIRECTION_Y_DOWN_MAX
comment  2B11
label    2B11 Direction_Y_Inc
comment  2B16
comment  2B16 Test if alien has hit a platform, if yes, bounce off with direction change, else return
label    2B16 Test_Platform_Collision_Bounce
lcomment 2B1B 1xxx_xxx = Collision
comment  2B1D
comment  2B1D Collision detected, test if direction X is changing
deflabel 2B1E OBJECT_DIRECTION_X
lcomment 2B1F xxxx_x1xx = Direction X change
comment  2B24
comment  2B24 Test if direction Y is changing, down to up i.e. hitting top surface of platform
comment  2B24 Note collsion going up has neither X or Y flag triggered
deflabel 2B25 OBJECT_DIRECTION_Y
lcomment 2B26 xxxx_1xxx - Direction Y change
comment  2B2B
comment  2B2B Test object direction Y i.e. moving downwards, return if positive, else invert direction Y
comment  2B2F
comment  2B2F Invert direction and add $03, which appears to be removed later
label    2B2F Invert_Direction_X_or_Y
binary   2B30
comment  2B36
label    2B36 Do_RTS
comment  2B37
comment  2B37 Test object direction X, sometimes clips platform, passes this code but no direction X change,
comment  2B37 probably the MASK_01 fails
label    2B37 Invert_Direction_X
comment  2B3C
comment  2B3C Mask wasn't set, direction X not changed object skimmed platform
comment  2B3C Test object direction X, if object is going down, return, else, reverse direction X
comment  2B42
comment  2B42 If Direction is up or left, return
label    2B42 Invert_Direction_Alternate
binary   2B47
comment  2B46
comment  2B46 Object is going down or right, invert direction and store back to object
comment  2B4B
comment  2B4B Test if Jetman is onscreen
label    2B4B Spawn_Rocket_Modules_Fuel_Cell
binary   2B4F
comment  2B52
label    2B52 Spawn_RMFC_RTS
comment  2B53
comment  2B53 Return if Jetman not only flying or standing or no rocket module/fuel onscreen
label    2B53 Spawn_RMFC
deflabel 2B54 NOT_FLYING_AND_NOT_STANDING
comment  2B5C
comment  2B5C Return if ship is built and fuelled up
deflabel 2B60 SHIP_BUILT_AND_FUELLED_UP
comment  2B63
comment  2B63 Use counter to randomly spawn another Fuel Cell
binary   2B66
binary   2B68
comment  2B6B
comment  2B6B Init Rocket Part or Fuel Cell object (8 attributes)
deflabel 2B6C NUM_OBJECT_PARAMS
comment  2B6D
label    2B6D Loop_Init_Obj_Rocket_Or_Fuel
comment  2B76
comment  2B76 Spawn object at a random X position
comment  2B7F
label    2B7F Init_Obj_Rocket_Or_Fuel_Table
const    2B82
comment  2B87
label    2B87 Init_Obj_Valuable_Table
const    2B8A
comment  2B8F
label    2B8F Spawn_Valuables
lcomment 2B92 Zero bits 6 & 7 i.e. 00xxxxxx
binary   2B92
binary   2B93
comment  2B96
label    2B96 Spawn_Vals_RTS
comment  2B97
comment  2B97 Return if Jetman not only flying or standing or valuable onscreen
label    2B97 Spawn_Vals
deflabel 2B98 NOT_FLYING_AND_NOT_STANDING
comment  2BA0
comment  2BA0 Use counter to randomly spawn another valuable
binary   2BA3
comment  2BA6
comment  2BA6 Init Flashing Valuable object (8 attributes)
deflabel 2BA7 NUM_OBJECT_PARAMS
comment  2BA8
label    2BA8 Loop_Init_Obj_Valuable
comment  2BB1
comment  2BB1 Spawn object at a random X position
comment  2BB7
comment  2BB7 Use IRQ random value to setup next object type
binary   2BBA
comment  2BC0
comment  2BC0 Bit 3 wasn't set, so zero all bits apart from bit 3
comment  2BC0 Bit 3 will make the object the gemstone which cycles through all colours
binary   2BC1
comment  2BC2
comment  2BC2 Make the valuble type $2x, used as an offset into the UDG data
label    2BC2 Store_Valuable_Type
binary   2BC3
comment  2BC7
comment  2BC7 $03C0 object starts as Rocket Module Middle, then becomes Fuel Cell
label    2BC7 Load_ZP_Params_Rocket_Or_Fuel
lcomment 2BCD ZP00/01
const    2BCD
word     2BCE
const    2BCE
lcomment 2BCE Object Address
comment  2BD4
comment  2BD4 Object's valuable type used as an index into the UDG data
deflabel 2BD5 OBJECT_VALUABLE_TYPE_PARAM
comment  2BDE
comment  2BDE Use VIC raster value to create a random X parameter for new object
label    2BDE Get_Random_Position_X
binary   2BE2
comment  2BE8
comment  2BE8 Table of possible X positions for spawned new object
label    2BE8 Object_Position_X_Table
const    2BE8-2BF7
break    2BE8-2BF7
comment  2BF8
comment  2BF8 Store Obj_Laser_0 address in ZP_08/09 ($0388)
label    2BF8 Test_Laser_Hits_1
deflabel 2BF9 OBJ_LASER_0_LO
deflabel 2BFD OBJ_LASER_0_HI
comment  2C00
comment  2C00 Store number of lasers (4) for processing to ZP_02
deflabel 2C01 MAX_LASERS
comment  2C04
comment  2C04 Store current object X and Y for laser hit test in ZP_06/07
deflabel 2C05 OBJECT_POSITION_Y_PARAM
comment  2C0A
comment  2C0A Register Y becomes Object Position X parameter
comment  2C10
comment  2C10 Test if laser Position X value has bit 2 set
label    2C10 Loop_Test_Laser_Hit
deflabel 2C11 LASER_POSITION_X_PARAM
comment  2C19
comment  2C19 Register Y becomes Laser next Position X parameter
comment  2C19 Test if laser next Position X value has bit 2 set
comment  2C21
label    2C21 Test_Laser_Object_Active
deflabel 2C22 OBJECT_TYPE_PARAM
comment  2C27
comment  2C27 Register Y becomes Laser Position Y parameter
comment  2C27 Compare laser and object Position Y value, if CMP fails, return
comment  2C31
comment  2C31 Register Y becomes Laser Position X parameter
comment  2C31 Zore the bottom 3 bits of Position X, making it a character-sized column reference
comment  2C31 Test if object is to the left or right of the Laser object
binary   2C35
comment  2C3D
comment  2C3D Invert the result of the comparison? Not sure...
binary   2C3E
label    2C42 Test_Laser_And_Obj_Position_X
comment  2C42
comment  2C42 Compare Position X of object and later, see if they overlap and therefore there is a hit
comment  2C46
comment  2C46 Object hit by laser, return $80 in ZP_02 (i.e. negative number)
comment  2C4A
comment  2C4A Zero bit 2 of laser X parameter, probably to diasble it later
deflabel 2C4B LASER_POSITION_X_PARAM
binary   2C4F
comment  2C53
comment  2C53 Increment current object address and decrement object counter
label    2C53 Goto_Next_Laser
deflabel 2C57 OBJECT_STRUCTURE_SIZE
comment  2C5A
comment  2C5A Decrement object counter, return when all processed
comment  2C5F
label    2C5F Test_Laser_Hits
comment  2C6A
label    2C6A WAVE_0_FUZZBALL
comment  2C6F
comment  2C6F Alien not hit by laser, test if alien hit platform, if yes explode,
comment  2C6F else test if alien hit Jetman
comment  2C78
comment  2C78 Alien has been hit by laser, use current player wave to create points table offset
label    2C78 Alien_Hit_Score_Update
binary   2C7B
comment  2C7E
comment  2C7E Get score high byte and save
comment  2C84
comment  2C84 Get score low byte and save
comment  2C8C
label    2C8C Chg_Obj_To_Explosion_Then_Next
comment  2C92
comment  2C92
comment  2C92
comment  2C92
comment  2C92 Test if object has collided with Jetman, if not, update position and display object
comment  2C92 DEBUG Change $2C95 A5 02 to A9 02 for Jetman Invulnerabilty (LDA Immediate instead of ZP)
comment  2C92 In MAME Debugger, use "fill 2C95,1,A9"
label    2C92 Display_Object_Position_Update
comment  2C99
comment  2C99 Alien has hit Jetman
comment  2C9F
comment  2C9F Get object Direction & Position Y and use to calculate new X value
label    2C9F Update_Object_Position
deflabel 2CA0 OBJECT_DIRECTION_X_PARAM
comment  2CA3
comment  2CA3 Register Y becomes offset to Object Position X parameter
comment  2CAB
comment  2CAB Take care of X screen wrapping (note $f0=-16 decimal)
comment  2CAF
deflabel 2CB0 SCREEN_WIDTH_PIXELS
comment  2CB3
label    2CB3 Update_Object_X_Position
comment  2CB5
comment  2CB5 Get object Direction & Position and use to calculate new Y value
deflabel 2CB6 OBJECT_DIRECTION_Y_PARAM
comment  2CB9
comment  2CB9 Register Y becomes offset to Object Position Y parameter
comment  2CC3
comment  2CCC
label    2CCC Wrap_Object_X_Position_Left
deflabel 2CCD SCREEN_WIDTH_PIXELS
comment  2CD1
label    2CD1 Wrap_Object_X_Position_Right
deflabel 2CD2 _100_MINUS_SCREEN_WIDTH_PIXELS
comment  2CD6
comment  2CD6 Wait until start of wave flashing score countdown has reached zero
label    2CD6 Init_Alien_Objects_Flash_Cntdn
comment  2CDB
label    2CDB Alien_Points_Lookup_Table
word     2CDB-2CE2
const    2CDB-2CE2
comment  2CE3
comment  2CE3 Test to see if Jetman is being displayed yet, return if not
label    2CE3 Test_Jetman_Displayed
binary   2CE7
deflabel 2CE9 JETMAN_FLYING
deflabel 2CED JETMAN_STANDING
comment  2CF1
comment  2CF1 Set Object List Pointer to first alien object
label    2CF1 Init_Alien_Object_Next
deflabel 2CF2 OBJ_ALIEN_0_LO
deflabel 2CF6 OBJ_ALIEN_0_HI
comment  2CF9
comment  2CF9 Setup next alien objects, to a maximum of 6
comment  2CF9 DEBUG Set $2CFA to 1 to spawn only 1 alien
comment  2CF9 In MAME Debugger, use "fill 2CFA,1,1"
deflabel 2CFA NUM_ALIENS_MAX
deflabel 2CFE OBJECT_TYPE_PARAM
comment  2CFF
comment  2CFF Test if alien object is currently used, if not initiate it
label    2CFF Loop_Next_Object
comment  2D03
comment  2D03 Alien object is used, so move pointer to next object
deflabel 2D07 OBJECT_STRUCTURE_SIZE
comment  2D0A
comment  2D0A Decrement alien countdown, return when it reaches zero
comment  2D0F
comment  2D0F Initiate new alien object
comment  2D0F Incoming Register Y always 0
comment  2D0F Set alien object type depending on current wave i.e. 0, 1, 2 or 3
label    2D0F Init_Alien_Object
binary   2D12
comment  2D19
comment  2D19 Set initial object Position X to 1
comment  2D1D
comment  2D1D Register Y becomes Direction X, initiate randomly using IRQ counter
binary   2D22
binary   2D25
comment  2D28
comment  2D28 Register Y becomes Position Y, initiate randomly using IRQ counter already in X
binary   2D2B
binary   2D2D
comment  2D30
comment  2D30 Register Y becomes Direction Y, set diagonal movement or not randomly
binary   2D32
comment  2D35
comment  2D35 Register Y becomes object Colour, store 0 or 1 in ZP02
binary   2D38
comment  2D3B
comment  2D3B Set object colour randomly, lookup table has 2 colours per wave
binary   2D3F
comment  2D49
comment  2D4C
label    2D4C Wave_Alien_Type_Lookup
deflabel 2D4C WAVE_0_FUZZBALL_
break    2D4C
deflabel 2D4D WAVE_3_SAUCER_
break    2D4D
deflabel 2D4E WAVE_2_SPHERE_
break    2D4E
deflabel 2D4F WAVE_1_CROSS_
break    2D4F
comment  2D50
label    2D50 Wave_Alien_Colour_Lookup
deflabel 2D50 COLOUR_RED
deflabel 2D51 COLOUR_BLUE
deflabel 2D52 COLOUR_CYAN
deflabel 2D53 COLOUR_YELLOW
deflabel 2D54 COLOUR_BLUE
deflabel 2D55 COLOUR_YELLOW
deflabel 2D56 COLOUR_RED
deflabel 2D57 COLOUR_PURPLE
comment  2D58
comment  2D58 ----------------------------------------------------------
comment  2D58 FUNCTION : Tests if Jetman and the current object have
comment  2D58 \           overlapped i.e. collided. Object can be rocket
comment  2D58 \           part, fuel cell, gem or alien.
comment  2D58 ENTRY : ZP_Obj_List_Ptr = Current Object
comment  2D58 \        Obj_Jetman_Looks = Status of Jetman
comment  2D58 EXIT  : ZP_01_Lo = $00 No hit / $80 = Collide
comment  2D58 ----------------------------------------------------------
label    2D58 Test_Jetman_Object_Collide
comment  2D5C
comment  2D5C Test to see if Jetman is being displayed yet, set No_Collision and return if not
binary   2D60
deflabel 2D62 JETMAN_FLYING
deflabel 2D66 JETMAN_STANDING
lcomment 2D67 Yes, branch
comment  2D69
label    2D69 Set_No_Collision_And_Return
deflabel 2D6A NO_COLLISION
comment  2D6E
label    2D6E Compare_Obj_Jetman_Position_X
comment  2D6E Start with default No Collision
deflabel 2D6F NO_COLLISION
comment  2D72
comment  2D72 Register Y becomes offset to objects Position X, compare to Jetman's Position X and
comment  2D72 branch if object is to the left of Jetman
comment  2D7B
comment  2D7B Perform an Absolute on the result of the Position X comparison
comment  2D80
label    2D80 Test_Collision_Position_X
deflabel 2D81 HITBOX_X
comment  2D84
comment  2D84 Compare_Obj_Jetman_Position_Y
comment  2D84 Register Y becomes offset to objects Position Y, compare to Jetman's Position Y and
comment  2D84 branch if object is above Jetman
comment  2D8E
comment  2D8E Perform an Absolute on the result of the Position Y comparison
comment  2D93
comment  2D93 Test_Collision_Position_Y, note different collision range for above ($12) and below ($0C)
deflabel 2D94 HITBOX_Y_BELOW
comment  2D95
label    2D95 Set_Compare_Result_And_Return
comment  2D97
comment  2D9B
deflabel 2D98 COLLISION
label    2D9B No_Collision_Return
comment  2D9C
comment  2D9C Test_Collision_Position_Y, note different collision range for above ($12) and below ($0C)
label    2D9C Test_Collision_Position_Y
deflabel 2D9D HITBOX_Y_ABOVE
comment  2DA1
comment  2DA1 YOU ARE HERE########################################################################
label    2DA1 Restore_Player_Objects
comment  2DA6
comment  2DA9
label    2DA9 Restore_Player_Objects_1
comment  2DAE
deflabel 2DAF OBJECT_TYPE_VALUABLE
comment  2DB2
comment  2DB5
label    2DB5 Restore_Player_Objects_2
lcomment 2DBB ZP00/01
lcomment 2DBC Object Address
word     2DBC
comment  2DBF
comment  2DC5
label    2DC5 Restore_Player_Objects_3
comment  2DCB
label    2DCB Restore_Player_Objects_4
comment  2DD1
label    2DD1 Loop_Restore_Player_Objects
comment  2DDD
label    2DDD Set_Object_UDG_Colour
comment  2DE3
comment  2DE8
label    2DE8 Restore_Player_Objects_6
lcomment 2DEC Current wave modulus 4
binary   2DEC
comment  2DF1
comment  2DF9
comment  2DFF
label    2DFF Dec_Saved_Obj_List_Params_by_10
comment  2E06
comment  2E0D
comment  2E14
comment  2E17
comment  2E17 Aliens keep moving also
label    2E17 ROCKET_ASCEND
lcomment 2E1A Object height offset
lcomment 2E1C Load object height i.e. Rocket
lcomment 2E1E Object hit top yet
lcomment 2E20 Yes, branch
lcomment 2E23 Calculate new height
lcomment 2E25 Store new height i.e one pixel up
comment  2E27
comment  2E27 Trigger rocket flight sound
comment  2E31
label    2E34 Rocket_At_Top
comment  2E4E
comment  2E4E Flames stop a little way before bottom
label    2E4E ROCKET_DESCEND
comment  2E51
comment  2E51 Trigger rocket flight sound
comment  2E5B
comment  2E5B Move object Y position down 1 pixel, stopping at bottom i.e. $AF
lcomment 2E5B 03 = Height of object
lcomment 2E64 Hit bottom of playarea
comment  2E68
comment  2E68 Set current object type to a crash
comment  2E74
comment  2E74 This always seems to be a test for Jetman collide with Rocket
label    2E74 ROCKET_BOTTOM_MODULE
lcomment 2E77 Jetman collided with rocket?
lcomment 2E7A Set by collision test
lcomment 2E7C Collision? If no, branch
comment  2E7E
comment  2E7E Collision occured, handle it
lcomment 2E80 Get number of fuel cells delivered into rocket
lcomment 2E82 Rocket fully fueled up?
deflabel 2E83 FUELLED_UP
lcomment 2E84 No, branch
comment  2E86
comment  2E86 Set Rocket object to Ascend
deflabel 2E87 ROCKET_ASCENDING
comment  2E8F
comment  2E8F Don't display Jetman next time? Also zeroes Jetman X coord.
word     2E93
comment  2E96
comment  2E9C
comment  2EAC
label    2EAC Rocket_Fuelled_Up
label    2EB5 Rocket_Fuelled_Up_1
comment  2EC0
label    2ECA Rocket_Fuelled_Up_2
label    2EFD Rocket_Fuelled_Up_3
label    2F01 Rocket_Fuelled_Up_4
label    2F07 Rocket_Fuelled_Up_5
comment  2F0D
comment  2F13
label    2F16 Rocket_Fuelled_Up_6
lcomment 2F1A ZP0C_Col_RAM_Ptr_Lo
lcomment 2F1D ZP0C_Col_RAM_Ptr_Lo
lcomment 2F1F ZP0C_Col_RAM_Ptr_Lo
lcomment 2F24 ZP0C_Col_RAM_Ptr_Lo
lcomment 2F26 ZP0D_Col_RAM_Ptr_Hi
lcomment 2F2A ZP0D_Col_RAM_Ptr_Hi
comment  2F31
comment  2F31 Test if rocket part has landed, $08=middle part, $10=top part
comment  2F31 $18=Fuel (?!)
label    2F31 Rocket_Part_Or_Fuel_Dropped
deflabel 2F32 OBJECT_POS_Y_WHEN_LANDED_PARAM
comment  2F39
comment  2F39 Rocket part dropped, add current Y postion to landed Y position
comment  2F39 and test to see if object has hit the ground
deflabel 2F3B OBJECT_POSITION_Y_PARAM
deflabel 2F40 SCREEN_BOTTOM
comment  2F43
comment  2F43 Rocket part landed, activate next object i.e. set
comment  2F43 status = not dropping and not picked-up by Jetman
comment  2F43 Note, using direct addressing, not using Y offset
lcomment 2F46 Set bit 0
binary   2F47
comment  2F4E
comment  2F4E Multiply rocket direction(???) by $10 and store
comment  2F57
comment  2F57 Subtract ZP13 ($10 when rocket middle landed, $20 for top section landed) from
comment  2F57 Rocket Part Bottom Y position and store in Obj_Y_Position_2
comment  2F65
comment  2F65 Turn Rocket Middle Section object off in list
label    2F65 Disable_Object_In_List
comment  2F6A
comment  2F6A Trigger sound for valuable pickup and rocket part/fuel cell
comment  2F6A landing on rocket base
comment  2F74
label    2F77 Fuel_Dropped
deflabel 2F78 OBJECT_POSITION_Y_PARAM
deflabel 2F7C FUEL_POSITION_Y_WHEN_LANDED
comment  2F7F
comment  2F7F Fuel cell has landed, increment the counter
comment  2F8E On game startup whilst score flash, no Jetman, no Aliens, alternates between 03B8 and 03C0 i.e. two rocket parts
comment  2F8E On game startup 03B8+04=00, 03C0+4=01
comment  2F8E Pickup  middle section 03B8+04=00, 03C0+4=03
comment  2F8E Falling middle section 03B8+04=00, 03C0+4=07
comment  2F8E Landed  middle section 03B8+04=01, 03C0+4=07
comment  2F8E 03C0 turns into a 0E_Valuable, 03B8 goes round the same cycle as 03C0
comment  2F8E 03B8 becomes a fuel cell
comment  2F8E When middle rocket section deposited, only 03B8 checked, despite dropped valuable
comment  2F8E When top rocket section lifted, still only 03B8 checked, despite dropped valuable
comment  2F8E When top rocket section deposited and fuel dropped, still only 03B8 checked
comment  2F8E When fuel picked-up and dropping onto rocket, still 03B8 checked.
comment  2F8E When fuel drops into rocket, for a short time, no interrupt until next fuel cell drops 03B8
label    2F8E ROCKET_PART_OR_FUEL
comment  2F91
comment  2F91 Test status of the rocket part or fuel cell object
comment  2F91 001=Ready to Pickup, 011=Picked-up, 111=Dropped/Landed
deflabel 2F92 LIFECYCLE_STATE
comment  2FA4
comment  2FA4 Test if Jetman has collided with a rocket part or fuel cell?
comment  2FAB
comment  2FAB Test if rocket part or fuel cell has landed on a platform
comment  2FAB Rocket top part only falls when middle part deposited
comment  2FAB DEBUG NOP the JSR and rocket part or fuel keeps falling
comment  2FB2
comment  2FB2 Move object down by 2 pixels, make Y an odd number
label    2FB2 Rocket_Part_Or_Fuel_Move_Down
deflabel 2FB3 OBJECT_POSITION_Y_PARAM
comment  2FBD
comment  2FBD Load current object attributes into ZP variables and object index into A
label    2FBD Setup_Object_Addr_Rocket_Fuel
comment  2FC3
comment  2FC3 Using index into object data, get addr of object data to A and Y and setup into ZP
label    2FC3 Setup_Object_Addr
comment  2FCB
comment  2FCB Do it again to setup the object dimensions
comment  2FDA
comment  2FDA Return object's UDG data address offset for Rocket Middle Section/Fuel
comment  2FDA depending on which of the four levels (or multiple of) the player is currently on
label    2FDA Get_Obj_UDG_Data_Addr_Ship_Lvl
comment  2FDC
comment  2FDC Calculate and return object's UDG data address offset based on A e.g. player wave
comment  2FDC First ship is for levels 0-3, second ship for levels 4-7 then repeat
label    2FDC Get_Obj_UDG_Data_Addr_Ship_A
binary   2FDE
deflabel 2FE0 OBJECT_PARAM
comment  2FE5
comment  2FE5 Using A as offset, Load A and Y with address of Ship, Fuel or Valuable UDG data
label    2FE5 Get_Obj_UDG_Data_Addr_S_F_V
comment  2FEE
comment  2FEE At point when Jetman picks up Rocket or Fuel module
label    2FEE Jetman_Collide_Rocket_Fuel
lcomment 2FF1 Diag attrib? Not sure...
lcomment 2FF5 Zero all bits except bit 1 i.e. 000000x0
comment  2FF9
comment  2FF9 Jetman pickup Rocket Module / Fuel Cell = 100 points
word     2FFD
const    2FFD
comment  3003
comment  3003 Trigger collision pickup sound
lcomment 3005 Flame object X pos??
lcomment 300A Flame object direction?
comment  300D
lcomment 3012 Store current Jetman object X pos into current object?
lcomment 3019 Store current Jetman object Y pos into current object?
label    301E Copy_Jetman_XY_To_Object
comment  3028
comment  302F
label    303E Copy_Jetman_XY_To_Object_0
comment  3042
comment  304A
label    3051 Copy_Jetman_XY_To_Object_1
label    3054 Load_Rocket_or_Fuel_UDGs
label    3057 Load_Rocket_or_Fuel_UDGs_1
label    305A Load_Rocket_or_Fuel_UDGs_2
comment  3063
label    3063 Update_Score
lcomment 3065 If P2, setup P2 Score instead of P1 and then return after the param setup below
comment  3067
comment  3067 Read ZP Params P1 Score
lcomment 306A ZP_03_Lo
lcomment 306B P1 Score in ZP
word     306B
comment  306E
label    306E Add_3_Digit_BCD_To_Score
lcomment 306E 3 digits
comment  3070
comment  3070 Add units
lcomment 3070 Set Decimal Mode
comment  3078
comment  3078 Add tens
comment  307F
comment  307F Add hundreds
lcomment 3086 Clear Decimal Mode
comment  3087
lcomment 3087 Decide if working with P1 or P2
label    308e Display_P2_Score_JMP
label    3091 Read_ZP_Params_P2_Score
lcomment 3094 ZP_Temp_2
lcomment 3095 P2 Score in ZP
word     3095
comment  309B
label    309B EOR_Then_TPC1_Or_TPCY
binary   309c
comment  30A1
lcomment 30A1 Save A
comment  30A9
lcomment 30AC Restore A
comment  30AD
comment  30B3
comment  30B3 ----------------------------------------------------------
comment  30B3 Platform Collision Test
comment  30B3 ----------------------------------------------------------
comment  30B3 FUNCTION  : setsoe
comment  30B3 \            snethuoistn
comment  30B3 \            ethonshu.
comment  30B3 CALLED BY :
comment  30B3 CALLS     : Nothing
comment  30B3 ARGUMENTS : ZP_xxxx
comment  30B3 \            satoehsaeuht
comment  30B3 \            sathoeusanteho
comment  30B3 ----------------------------------------------------------
comment  30B3 Triggers with Jetman and 3 objects, then again with Jetman and different 3 objects, then...
comment  30B3 ZP02 Return Codes:

comment  30B3 $8F 0001_1111 Alien dl to dl corner skim
comment  30B3 $8F 0001_1111 Alien dl to dr corner hit

comment  30B3 $8E 0001_1110 Alien ul to ur

comment  30B3 $8B 0001_1011 Alien dl to ul

comment  30B3 $8A 0001_1010 Alien dl to ul

comment  30B3 $89 0001_1001 Alien dl to ul

comment  30B3 $88 0001_1000 Alien dl to ul
comment  30B3 $88 0001_1000 Alien dr to ur

comment  30B3 $87 0001_0111 Alien dr to dl

comment  30B3 $86 0001_0110 Alien ul to ur corner hit

comment  30B3 $83 0001_0011 Alien ul to ul
comment  30B3 $83 0001_0011 Alien ur to dr

comment  30B3 $82 0001_0010 Alien ul to dl

comment  30B3 $81 0001_0001 Alien ul to dl
comment  30B3 $81 0001_0001 Alien ur to dr

comment  30B3 $80 0001_0000 Alien ur to dr
comment  30B3 $80 0001_0000 Alien ul to dl
comment  30B3 Bit 0:
comment  30B3 Bit 1:
comment  30B3 Bit 2:
comment  30B3 Bit 3:
label    30B3 Test_Platform_Collision
deflabel 30B4 OBJECT_POSITION_X
lcomment 30B5 1st run: Points to 03C0+1 Rocket Middle Section horizontal position = $50 i.e. #10 characters across
lcomment 30B7 1st run: Y=50
comment  30B9
comment  30B9 Register Y becomes OBJECT_POSITION_Y
lcomment 30BB 1st run: Points to 03C0+3 Rocket Middle Section vertical   position = $5F i.e. on middle platform
lcomment 30BD 1st run: X=5f
comment  30BF
lcomment 30BF Set Temp4 to address of data table at 31B6
comment  30C2
comment  30C2 Initialise collision status, which becomes the subroutine return code
label    30C2 Test_Platform_Collision_X
comment  30C6
comment  30C6 Load Position X of platform (indexed by Register Y) and subtract object Position X
comment  30CD
comment  30CD Object is to the left of the platform, set status bit 1
comment  30D4
label    30D4 Test_Platform_Collision_1
binary   30D5
comment  30D8
comment  30DF
label    30DF Test_Platform_Collision_1_Skip
binary   30E0
comment  30E3
comment  30E7
comment  30EC
comment  30EC LOAD POSITION Y OF PLATFORM
label    30EC Test_Platform_Collision_Y
comment  30F4
comment  30F8
label    30FD Test_Platform_Collision_Y_Skip
binary   30FE
comment  3101
deflabel 3103 OBJECT_TYPE_PARAM
binary   3107
binary   3109
comment  310D
binary   310E
comment  310F
label    310F Move_Toward_RTS
comment  3113
comment  3118 y reg is pointer into lookup table, 3 groups of 3
comment  3118
label    3118 INY_3
lcomment 3118 3 iny's when moving from Y check to Y check
comment  3119
label    3119 INY_2
lcomment 3119 2 iny's when moving from X check to X check as y already inc'd
lcomment 311B Temp5 used as 3-2-1 countdown
comment  311F
deflabel 3120 OBJECT_POSITION_Y_PARAM
comment  3127
deflabel 3128 SCREEN_BOTTOM
comment  312B
comment  312D
label    312D STA_Collision_Status_RTS
comment  3130
label    3130 CMP20_RTS
binary   3131
comment  3134
comment  3138
label    3138 Update_Collision_Status_RTS
binary   3139
const    3139
comment  313C
label    313C TPC_RTS
comment  313D
label    313D PLO_CMP_1A_Move_Toward_RTS
comment  3143
label    3143 Load_Platform_Data_Table_Addr
lcomment 3143 Loads address to data from $31B6 i.e. 10 40 03 50 60 01 88 30 03
deflabel 3144 PLATFORM_DATA_TABLE_ADDR_LO
comment  3147
deflabel 3148 PLATFORM_DATA_TABLE_ADDR_HI
comment  314B
deflabel 314C PLATFORM_NUMBER_COUNTDOWN
comment  314F
comment  314F Initial index into the Platform Data Table
comment  3152
label    3152 Draw_Platforms
label    3155 DP_1
lcomment 3155 Get X value from lookup table ($10)
lcomment 3157 \ and store
comment  3159
lcomment 315A Get Y value from lookup table ($40)
lcomment 315C \ and store
comment  315E
lcomment 315F Get ??? value from lookup table ($03)
lcomment 3161 \ and store
comment  3163
comment  316B
comment  316B Load Temp_3 with addr of left end platform UDG char
comment  3173
comment  3173 Copy left end platform UDG char to RAM, bytes 9 per column
comment  3178
comment  3178 Copy middle platform and right end UDG chars to RAM, 9 bytes per column
label    317B Loop_Next_Char
comment  3180
comment  3186
comment  3186 Set the colour mapping for the platforms to Green
deflabel 3192 COLOUR_GREEN
label    3193 DP_2
lcomment 3193 ZP0C_Col_RAM_Ptr_Lo
label    31A2 Next_UDG_Char_Loop_Next_Char
label    31A8 Next_UDG_Char
comment  31B6
comment  31B6 Platform data table, 3 platforms
const    31B6-31BE
lcomment 31B6 X Y #Num_middle_chars
break    31B9
lcomment 31B9 X Y #Num_middle_chars
break    31BC
lcomment 31BC X Y #Num_middle_chars
comment  31BF
label    31BF A_Left_Right_Impact
deflabel 31C0 JETMAN_DIRECTION_X_PARAM
comment  31C7
comment  31C7 Load and test Jetman X Direction/Velocity
comment  31CB
label    31CB C_Jump_P
comment  31CE
label    31CE B_Fly_Right_Impact
label    31D4 B_Jump_Q
comment  31D7
label    31D7 SKIP_31D7
comment  31DF
comment  31DF BVS/BVC above means below code can only be jumped/branched to
label    31DF E_Fly_Left_Impact
comment  31E7
label    31E7 E_Jump_Q
comment  31EA
label    31EA SKIP_31EA
comment  31F2
comment  31F2
comment  31F2 BVS/BVC above means below code can only be jumped/branched to
comment  31F2 1xxx0001 = Upward impact
comment  31F2 1xxx1000 = Downward impact
comment  31F2 1xxxx1xx = Left or Right impact
comment  31F2 1xxx1110 = Top Right Corner impact
comment  31F2 1xxx0110 = Right impact
comment  31F2 1xxx0111 = Top Left impact
comment  31F2 1xxx0111 = Left impact
label    31F2 H_Jetman_Hits_Surface
comment  31F7
comment  31F7 Test Obj_Jetman_At_Rest???
deflabel 31F8 JETMAN_DIRECTION_Y_PARAM
comment  3200
label    3200 I_Left_Right_Up_Impact
comment  3208
comment  3208 Test Obj_Jetman_At_Rest???
label    3208 J_Flying_Up_Impact
deflabel 3209 JETMAN_DIRECTION_Y_PARAM
binary   3211
comment  3212
label    3212 K_Jump_U
comment  3215
label    3215 J_Jump_T
comment  3218
label    3218 M_Flying_Up_Impact_Bounce
label    3224 SKIP_3224
comment  3228
label    3228 N_Flying_Left
comment  3230
comment  323E
label    323E S_Flying_Right
comment  3246
label    3254 SKIP_3254
comment  3259 HOW DO YOU EVER GET HERE?
label    325E P_INC_A_Jump_Q
label    3264 R__Wrap_Left_To_Right
deflabel 3266 SCREEN_WIDTH_PIXELS
label    326A R__Wrap_Right_To_Left
label    326F P_TXA_Jump_R
label    3273 JETMAN_FLYING_
lcomment 3276 Returns A=%RLDU_F111
lcomment 327B Remove=Jetman+fuel/rocket part pick-up fly through platforms
label    3285 P_Update_Jetman_Position_X
deflabel 3286 JETMAN_DIRECTION_X_PARAM
comment  3291
binary   3295
label    32A2 Q_Store_Jetman_Direction_X
deflabel 32A3 JETMAN_DIRECTION_X_PARAM
label    32A6 R_Update_Jetman_Position_X
deflabel 32A7 JETMAN_POSITION_X_PARAM
comment  32A8
comment  32AB
comment  32AE
deflabel 32B7 SCREEN_WIDTH_PIXELS
label    32BA R__Store_Jetman_Position_X
comment  32BC
label    32C7 T_Update_Jetman_Position_Y
deflabel 32C8 JETMAN_DIRECTION_Y_PARAM
comment  32C9
lcomment 32CB Test for direction Down
lcomment 32CE Yes, branch
lcomment 32D0 Test for direction Up
lcomment 32D3 Yes, branch
comment  32D5
comment  32DE
label    32DE U_Store_Jetman_Direction_Y
comment  32E0
label    32E0 V_Update_Jetman_Position_Y
comment  32E1
comment  32E4
deflabel 32E9 SCREEN_BOTTOM
deflabel 32ED SCREEN_TOP
comment  32F0
comment  32F0 Y becomes index to Direction Y
comment  32F5
comment  32F5 Reverse the direction parameter
comment  32F7
comment  32F7 Gets called with either Jetman Type (index 0) or Jetman_Position_Y (index 3)
label    32F7 W_Store_Jetman_Parameter
comment  32F9
label    32F9 X_Jetman_Screen_Update
comment  32FF
comment  32FF Test for fire pressed
label    3309 No_Fire_Pressed
comment  330C
comment  330C Load and test Jetman Y Direction
label    330C Y_Update_Jetman_Direction_Y
comment  3318
label    3318 T_U_Set_Jetman_Direction_Y_Zro
comment  331D
label    331D V_D_Set_Jetman_Position_Y_Bott
comment  3321
label    3321 D_Set_Jetman_Standing
deflabel 3322 JETMAN_STATE_PARAM
comment  3325
comment  3325 ROL saves bit 7 (facing direction), LDA #$04 sets bit 2, ROR restores bit 7 and moves
comment  3325 bit 2 to bit 1 i.e. Jetman action is now Standing
comment  332C
label    332C Set_Jetman_Facing_Right
lcomment 332E Zero bit 7
binary   332F
comment  3337
label    3337 Set_Jetman_Facing_Left
lcomment 3339 Set bit 7
binary   333A
comment  3342
label    3342 Jetman_Wrap_Left_To_Right
deflabel 3344 SCREEN_WIDTH_PIXELS
comment  3348
label    3348 Jetman_Wrap_Right_To_Left
deflabel 3349 _100_MINUS_SCREEN_WIDTH_PIXELS
comment  334D
label    334D READ_CONTROLS
comment  3351
comment  3351 At start of each life, flash active player score before wave begins, until counter reaches zero
comment  3358
comment  3358 Display Jetman, colour jetman and display scores
comment  3367
label    3367 Flash_Display_Score_JMP
comment  336A
label    336A Read_Controls_1
lcomment 3370 Remove=Jetman+pickup flies/walks jiggle when standing on a platform
comment  3377
comment  3377 Jetman has walked off edge of platform, test if Position Y is negative, which
comment  3377 only appears to be the case when Jetman is below all the platforms
deflabel 3378 JETMAN_POSITION_Y_PARAM
comment  337D
label    337D Set_Jetman_Facing_Direction
deflabel 337E JETMAN_STATE_PARAM
comment  3385
comment  3385 Test Jetman direction
comment  3389
comment  3389 Jetman walking right, prepare new Direction X value
comment  338D
comment  338D Jetman walking left, prepare new Direction X value
label    338D Jetman_Walking_Left
comment  338F
label    338F Test_Collision_Status????
deflabel 3390 JETMAN_DIRECTION_X_PARAM
comment  3395
comment  3395 Set Zero flag as AND between between content of addr 2015 (i.e. 0000_0010) and A (i.e. ZP02)
comment  3395 DON'T KNOW WHY, guess need to decode ZP02 collision status
comment  3398
comment  3398 Move X into A without affecting the CPU status flags
comment  339B
comment  339D
label    339D Jetman_Not_Moving_X_Axis
comment  339F
label    339F Update_JM_Direction_Position_X
deflabel 33A0 JETMAN_DIRECTION_X_PARAM
comment  33A3
comment  33A3 Y becomes JETMAN_POSITION_X_PARAM
deflabel 33AC SCREEN_WIDTH_PIXELS
comment  33AF
label    33AF Store_Jetman_New_Position_X
lcomment 33B3 Test for direction Up
binary   33B4
lcomment 33B5 Yes, branch
comment  33BA
label    33BA Update_JM_Direction_Position_Y
deflabel 33BB JETMAN_DIRECTION_Y_PARAM
comment  33C0
comment  33C0 Move Jetman upwards by three pixels
label    33C0 Jetman_From_Standing_To_Flying
deflabel 33C1 JETMAN_POSITION_Y_PARAM
comment  33C9
comment  33C9 Change Jetman state from Standing to Flying
deflabel 33CA JETMAN_STATE_PARAM
comment  33D4
comment  33D4 VIA Port A Bit 2=Up, 3=Down, 4=Left, 5=Fire
comment  33D4 Port A read twice, 1st for Up/Down/Left, 2nd for Fire
comment  33D4 Port A reads $7C=%0111_1100 when nothing pressed i.e. joystick inputs are active low
comment  33D4 VIA Port B Bit 7=Left
comment  33D4 Port B read once for Right
comment  33D4 Port B reads $FF=%1111_1111 when nothing pressed i.e. joystick inputs are active low
label    33D4 Read_Joystick
lcomment 33D4 %xxxL_DUxx
lcomment 33D9 %1LDU_1111
binary   33DA
lcomment 33DB $FF when nothing pressed
comment  33DD
comment  33DD Read Fire button
lcomment 33DD %xxFx_xxxx
lcomment 33E2 %1111_F111
binary   33E3
lcomment 33E4 %1LDU_F111
lcomment 33E6 $FF when nothing pressed
comment  33E8
comment  33E8 Read direction Right
lcomment 33EA Set Port B direction all lines read
lcomment 33ED %Rxxx_xxxx
lcomment 33F0 %R111_1111
binary   33F1
lcomment 33F2 %RLDU_F111
lcomment 33F4 $FF when nothing pressed
comment  33F7
comment  33F7 If joystick selected, branch and return without reading keyboard
label    33F7 Read_Keyboard_Joystick
comment  33FF
comment  33FF Read Keyboard, only executed when joystick not selected
comment  33FF Setup outputs to enable reading of Keyboard matrix
lcomment 33FF Set Port A to all output
lcomment 3404 Set Port A outputs
lcomment 3409 Set Port B to all inputs
binary   3400
binary   3405
binary   340A
comment  340E
comment  340E Read keyboard matrix, multiple keys can be pressed for each direction and fire, see
comment  340E hardware documentation for more detail
comment  340E Read right & left input keys at the same time (L: Z C B M . RSHFT) (R: LSHFT X V N , /)
lcomment 340E %xxxR_Lxxx
lcomment 3414 %RL11_1111
binary   3415
lcomment 3416 %RL11_1111
comment  3418
comment  3418 Read Fire input keys, set 1 (S F H K : =)
lcomment 3418 %xxFx_xxxx
lcomment 341E %1111_F111
binary   341F
lcomment 3422 %RL11_F111
comment  3424
comment  3424 Read Fire input keys, set 2 (A D G J L ;)
lcomment 3424 %xxxx_xFxx
lcomment 3426 %1111_F111
binary   3427
lcomment 342A %RL11_F111
comment  342C
comment  342C Read Up input keys, set 1 (Q E T U O @ UA)
binary   342D
lcomment 3431 %xUxx_xxxx
lcomment 3436 %111U_1111
binary   3437
lcomment 343A %RL1U_F111
comment  343C
comment  343C Read Up input keys, set 2 (W R Y I P \*)
binary   343D
lcomment 3441 %xxxx_xxUx
lcomment 3447 %111U_1111
binary   3448
lcomment 344B %RL1U_F111
comment  344D
comment  344D Read Down input keys, set 1 and 2 (2 4 6 8 0 - HOM) & (1 3 5 7 9 + BP)
binary   344E
lcomment 3452 %Dxxx_xxxD
comment  345C
label    345C Read_Keyboard_Down
lcomment 345E %11D1_1111
binary   345F
lcomment 3462 %RLDU_F111
comment  3465
comment  3465 Reverse video the displayed score area for the active player
label    3465 Flash_Score
lcomment 346C ZP04
const    346C
lcomment 346D X Y position in pixels
const    346D
break    346F
comment  3470
label    3470 Flash_Score_1
comment  3473
comment  3473 Test IRQ counter, only continue once in 8 calls
binary   3476
comment  3479
deflabel 347A NUM_OF_COLUMNS_TO_REVERSE
comment  347B
label    347B Loop_Reverse_UDG_Column
deflabel 347C NUM_PIXEL_OF_LINES_TO_REVERSE
label    347D Loop_Reverse_UDG_Pixel_Line
comment  347D
comment  347D Get current byte of character, reverse it and write it back
binary   3480
comment  3483
comment  3483 All lines reversed? If no, loop back
comment  3486
comment  3486 All columns reversed? If yes, return
comment  3489
comment  3489 Move to next column by adding a columns-worth ($B0 #176) of pixel lines to 16-bit UDG RAM Address
deflabel 348D SCREEN_HEIGHT_PIXELS
comment  3490
comment  3496
comment  3499
label    3499 Flash_Score_RTS
comment  349A
label    349A Load_UDG_RAM_Addr_For_P2
lcomment 349D ZP04
lcomment 349E X Y position in pixels
const    349E
break    34A0
comment  34A4
comment  34A4 ----------------------------------------------------------
comment  34A4 Display_BCD_Bytes
comment  34A4 ----------------------------------------------------------
comment  34A4 FUNCTION  : Display
comment  34A4 \            Scores
comment  34A4 CALLED BY :
comment  34A4 CALLS     :
comment  34A4 ARGUMENTS : ZP_UDG_RAM_X ZP_UDG_RAM_Y = UDG array absolute position to display score at
comment  34A4 \            ZP_Ptr_To_Str             = Players score in ZP as BCD e.g. 12 34 56
comment  34A4 \            ZP_Temp_1                 = BCD byte counter i.e. number of bytes to display
comment  34A4 ----------------------------------------------------------
comment  34A4 Example for score of 12 34 56 at ZP51-53
label    34A4 Display_BCD_Bytes
lcomment 34A6 A = 12 BCD i.e. First score byte
comment  34A8
comment  34A8 Divide by $10 to isolate first digit
lcomment 34AB 12 has become 01
comment  34AC
comment  34AC Add $70, $40 gets subtracted in display routine, making 01 into a PETSCII "1"
comment  34B4
comment  34B4 Load first score byte again to display second score character
lcomment 34B6 A = 12 BCD i.e. First score byte
comment  34B8
comment  34B8 Zero top 4 bits to isolate second digit
lcomment 34B8 12 becomes 02
binary   34B9
comment  34BA
comment  34BA Add $70, $40 gets subtracted in display routine, making 02 into a PETSCII "2"
comment  34C1
comment  34C1 Increment addres pointer to next score byte
lcomment 34C3 Looks like a BUG, should inc ZP0F,
lcomment 34C5 but in JETPAC it'll never happen
comment  34C7
label    34C7 No_Increment_Hi_Byte
comment  34CC
comment  34CC ----------------------------------------------------------
comment  34CC NOT SURE WHAT THIS IS YET
comment  34CC ----------------------------------------------------------
comment  34CC FUNCTION  :
comment  34CC CALLED BY :
comment  34CC CALLS     :
comment  34CC ARGUMENTS :
comment  34CC ZP_PTR_TO_STR  = "COPYRIGHT`qyxs`An" or "JETPAC`GAME`SELEC"
comment  34CC ZP_ColourRAMPtr = "SP START GAME" or "JETPAC`GAME`SELEC"
comment  34CC ZP_UDG_RAM_X   = 08 A8 or 08 20
comment  34CC ZP_UDG_RAM_Y   = 08 A8 or 08 20
comment  34CC ZP_Addr_From   = 70 80 or 28 80
comment  34CC ----------------------------------------------------------
label    34CC Display_String_With_Setup
label    34D2
comment  34D2
comment  34D2 Get string first byte header data, contains colour data and reverse flag
comment  34D6
comment  34D6 Write a string of data to the screen, header byte includes reverse flag and colour attribute
comment  34D6 Save colour data and reverse flag to X
label    34D6 Display_String
comment  34D7
comment  34D7 Get character to display and test if bit 7 is set, which signifys end of string
comment  34DB
comment  34DB If final character then (branch, display, RTS) else (JSR, display, next char)
comment  34E3
comment  34E3 Restore character value after testing for end of string, excluding reverse bit
label    34E3 Display_Character
comment  34E6
comment  34E6 Setup character display colour
comment  34E9
comment  34E9 Display character on screen, saving Y and restoring afterwards
comment  34F0
comment  34F0 Colourize the character just written
comment  34F7
comment  34F7 Example for "F7 JOYSTICK" start position
comment  34F7 Convert X=$18 pixels from left, Y=$68 pixels from top, to Colour RAM Address $968D
label    34F7 Setup_Colour_RAM_Ptr
lcomment 34F7 ZP04 = $18
comment  34F9
comment  34F9 Divide X by 8 to get initial address Lo-byte
lcomment 34FC ZP0C = $03
comment  34FE
comment  34FE Divide Y by $10 and use as index into Colour RAM Row Offsets i.e. 9600, 9617, 962e etc.
comment  34FE to get address Hi-byte. Divided by $10 because there are 16 Y-pixels per Colour RAM tile.
lcomment 34FE ZP05 = $68
lcomment 3503 ZP05 = $06
comment  3505
comment  3505 Load from column offset table and add in the inital address Lo-byte
lcomment 3505 A = $8A
lcomment 350B ZP0C = $8D
comment  350D
comment  350D Add $9600 to address in ZP0D/0C to become $968D i.e. "F7 JOYSTICK" start position
lcomment 350F ZP0D/0C = $968D
comment  3512
label    3512 Colour_RAM_Row_Offsets
const    3512-351C
comment  351D
comment  351D Example for "F7 JOYSTICK" start position
comment  351D Convert X=$18 pixels from left, Y=$68 pixels from top, to UDG RAM Address $1278
label    351D Convert_XY_to_UDG_RAM_Addr
lcomment 351D ZP05 = $68
lcomment 351F
comment  3520
comment  3520 Divide X by 8 to get address Lo-byte
lcomment 3520 ZP04 = $18
lcomment 3524 ZP04 = $03
comment  3526
comment  3526 Load from column offset table
lcomment 3526 A = $21
lcomment 352D ZP05/04 = $0021
comment  352F
comment  352F Rotate 16-bit address left by 4 bits
label    3531 Loop_Rotate
lcomment 3536 ZP05/04 $0021 > $0210
comment  3538
comment  3538 Add stashed Y = $68 to address in ZP05/04
lcomment 353C ZP05/04 = $0278
comment  353E
comment  353E Add $1000 to address in ZP05/04 to become $1278 i.e. "F7 JOYSTICK" start position
lcomment 3542 ZP05/04 = $1278
label    3545 UDG_RAM_Column_Offsets
comment  3545
comment  3545 Bytes are middle two numbers in UDG RAM addr starting at $1000 e.g. $10B0, $1160 etc
const    3545-3557
comment  355C
comment  355C Fill 11 rows x 23 columns = 253 bytes = $FD bytes i.e. Colour_RAM $9600 to $96FC
label    355C Reset_Colour_RAM
const    355F
lcomment 3560 Number of bytes to fill
word     3560
const    3562
lcomment 3563 Start address of bytes to fill
word     3563
const    3565
lcomment 3566 Data byte to fill with (i.e. $01)
word     3566
const    3566
break    3566
break    3568
comment  356C
comment  356C Fill 22 rows x 8 lines x 23 columns = 4,048 bytes = $FD0 bytes i.e. UDG_RAM $1000 to $1FCF
label    356C Reset_UDG_RAM
const    356F
lcomment 3570 Number of bytes to fill
word     3570
const    3572
lcomment 3573 Start address of bytes to fill
word     3573
const    3575
lcomment 3576 Data byte to fill with (i.e. $00)
word     3576
const    3576
break    3576
break    3578
comment  3579
comment  3579 Fill ZP02/03 number of bytes of RAM starting at address ZP02/03 with data in ZP06
label    3579 Fill_RAM
label    357B Loop_Fill_RAM
comment  3584
label    3584 No_Inc_Addr_Hi
comment  358C
comment  3595
comment  3595 ----------------------------------------------------------
comment  3595 Copy Character ROM Character to User-Defined Graphics Memory
comment  3595 ----------------------------------------------------------
comment  3595 FUNCTION  : Copy an 8 byte Character ROM character to the
comment  3595 \            Used-Defined Graphics RAM e.g. to display a
comment  3595 \            text string or score.
comment  3595 CALLED BY :
comment  3595 CALLS     : Nothing
comment  3595 ARGUMENTS : ??? = Loaded with character to copy e.g. $71 for "1"
comment  3595 \            ??? BROKEN COMMENTS Addr_To is already setup, e.g. $1268 in UDG memory "F5 Keyboard".
comment  3595 \            ??? BROKEN COMMENTS Addr_To gets updated as part of this routine.
comment  3595 ----------------------------------------------------------
comment  3595 Character to copy stored in ZP06, create Character ROM address in ZP06/06 for this
comment  3595 value and copy 8 data bytes from at that address to UDG RAM address stored in ZP04/05
comment  3595 Example: Display "1" using $71 in ZP06
label    3595 Copy_Char_To_UDG_RAM_Setup
lcomment 3595 Clear address hi-byte
lcomment 3597 ZP07/06 = $0071
comment  3599
comment  3599 Character to display in ZP06, "1" = $71
comment  3599 $31st Character ROM character is "1" so subtract $40
lcomment 359E ZP07/06 = $0031
comment  35A0
comment  35A0 8 bytes per UDG RAM character definition, so multiply by 8 using four 16 bit ROLs
label    35A2 Loop_Multiply_by_8
lcomment 35A5 ZP07/06 progression:
lcomment 35A7 $0031 > $0062 > $00C4 > $0188
comment  35AA
comment  35AA Add $8000 Character ROM offset to address, $8188 is Character ROM address for character "1"
lcomment 35AE ZP07/06 = $8188
comment  35B0
comment  35B0 Copy 8 bytes to display a complete character
comment  35B0 Displayed character can be normal or reversed, e.g. for score or selected game options
label    35B6 Copy_Char_To_UDG_RAM
comment  35BD
comment  35BD Move 16-bit UDG RAM address to the next-right column, $B0=176=number of vertical pixels
label    35BD Next_Column
deflabel 35C1 SCREEN_HEIGHT_PIXELS
comment  35C4
comment  35CB
comment  35CB Copy 8 bytes to display a complete character, EOR reverses the byte displayed
label    35CB Copy_Char_To_UDG_RAM_Reversed
comment  35D7
label    35D7 Load_Object_Type_X_Y
deflabel 35D8 OBJECT_TYPE_PARAM
comment  35DD
comment  35E2
deflabel 35E3 OBJECT_POSITION_Y_PARAM
label    35E9 Load_Object_Type_X_Y_Colour
deflabel 35EA OBJECT_TYPE_PARAM
comment  35EF
comment  35F4
deflabel 35F5 OBJECT_POSITION_Y_PARAM
comment  35FA
deflabel 35FB OBJECT_COLOUR_PARAM
comment  3601
label    3601 Display_Object_With_Setup_1
comment  3604
label    3604 Display_Object_With_Setup_2
comment  360D
label    360D Display_Object_With_Setup_3
comment  3610
label    3610 Display_Object_With_Setup_4
comment  3619
comment  3619 When object is moving down the screen, the number of pixels it has moved down by will result
comment  3619 in a number of pixel lines at the top of the object that need to be EXOR'd to erase them
comment  3619 Initial EOR/CLC/ADC performs an ABS on old/new object Y position delta for use as loop index
label    3619 Erase_Object_Moving_Downward
comment  361E Note code from 361E & 3663 is basically the same until Erase_Draw, but
comment  361E using old and new object parameters
comment  3622
comment  3622 Set X to number of Y pixel-lines to erase only i.e. don't draw over the erase for this object
comment  3623
comment  3623 Subtract number of Y erase-only pixels from total object tile height and store to loop
comment  3623 index for later
comment  3626
comment  362D
comment  362D Erase old object data bytes from UDG data to screen RAM by EXORing
comment  362D ZP09 index decrements from $FF, ZP0E holds address of old UDG object data,
comment  362D ZP0C holds address of object data on screen to be written to
label    362F Loop_Erase_Down
comment  3635
comment  3635 Decrement pointer into UDG data and the loop index
comment  3639
comment  3639 Restore the number of pixel lines to erased and store to ZP13, then subtract it from
comment  3639 ZP09, the updated address offset for erase/draw the first/next part of the new object
comment  363C
comment  3643
comment  3646
label    3646 Display_Object_With_Setup
comment  364C
label    364C Display_Object
comment  364E ZP08 and ZP09 used as index into UDG RAM for old object and new object data
comment  3652
comment  3652 ZP03 & ZP0B contain heights of the old and new object bitmaps from the UDG graphics data
comment  3652 e.g. Alien Cross object height is $0A pixels/lines
comment  3652 Rocket is made of 3x2 tiles, fuel cell 1x2, Jetman 1x2 or 1x3
comment  3656
comment  365A
comment  365A Test if updated object Y position has changed, if yes, horizontal pixels can be erased
comment  365A from top or bottom of old object that are outside new object position, else jump
comment  365A directly to erase/draw routine
comment  3663
comment  3663 Erase_Object_Moving_Upward, see also comments for Erase_Object_Moving_Downward
comment  3663 as it's basically the same code with a few tweaks
comment  3667
comment  3667 Set X to number of Y pixel-lines to be erased only i.e. no following draw for this object
comment  3668
comment  3668 Subtract number of Y erase-only pixels from total object tile height and store to loop
comment  3668 index for later
comment  366B
comment  3672
comment  3672 Erase old object data bytes from UDG data to screen RAM by EXORing
comment  3672 ZP08 index decrements from $FF, ZP06 holds address of old UDG object data,
comment  3672 ZP04 holds address of object data on screen to be written to
label    3674 Loop_Erase_Up
comment  367A
comment  367A Decrement pointer into UDG data and the loop index
comment  367E
comment  367E Restore the number of pixel lines to erased and store to ZP13, then subtract it from
comment  367E ZP08, the updated address offset for erase/draw the first/next part of the new object
comment  367F
comment  3681
comment  3688
comment  3688 Erasure of old object and drawing of new object is done in the same code loop,
comment  3688 first you erase the old line from screen memory using EXOR, then you write back
comment  3688 to the same line with the new object data
comment  3688 First test to see if old object fully erased, if yes jump to draw updated params
label    3688 Erase_Old_Object
comment  368E
comment  368E EXOR object data bytes from UDG data to screen RAM to erase
comment  3696
comment  3698
comment  3698 If new object fully drawn, don't try drawing more, erase next old object line
comment  369C
label    369C Draw_New_Object
comment  369E
comment  369E EXOR object data bytes from UDG data to screen RAM to draw
comment  36A6
comment  36AB
comment  36AB Test if more lines to be drawn for new object, if yes, branch
label    36AB Next_Object_Old_Update_Params
comment  36AF
comment  36AF Test if old object fully erased, if not, move to the next vertical column to erase
comment  36B3
comment  36B5
comment  36B5 Move UDG data 16-bit address pointer to the object data for the next column
comment  36BC
comment  36C2
comment  36C2 Move UDG RAM pointer to next vertical column
deflabel 36C6 SCREEN_HEIGHT_PIXELS
comment  36C9
comment  36CF
comment  36CF Test for full-screen wrap, $1ED1 is $FF less than the first byte past
comment  36CF UDG RAM (last byte = $1FCF)
comment  36DA
comment  36DA Handle full-screen wrap, $0FD0 is number of bytes used to define the full
comment  36DA UDG RAM. i.e. $16 x $17 x 8=$FD0
comment  36E1
comment  36E7
comment  36E7 Test if new object fully drawn, if not, move to the next vertical column to draw
label    36E7 Next_Object_New_Update_Params
comment  36EB
comment  36ED
comment  36ED Move UDG data 16-bit address pointer to the object data for the next column
comment  36F4
comment  36FA
comment  36FA Move UDG RAM pointer to next vertical column
deflabel 36FE SCREEN_HEIGHT_PIXELS
comment  3701
comment  3707
comment  3707 Test for full-screen wrap, $1ED1 is $FF less than the first byte past UDG RAM (last byte = $1FCF)
comment  3712
comment  3712 Handle full-screen wrap, $0FD0 is number of bytes used to define the full UDG RAM. i.e. $16 x $17 x 8=$FD0
comment  3719
comment  371F
label    371F JMP_Display_Object
comment  3722
label    3722 Zero_ZP0B_JMP_Display_Object
comment  3729
label    3729 Object_Width_Complete
comment  372D
comment  372D Test if both old and new object heights are the same, if yes, return
comment  3734
label    3734 JMP_Next_Obj_New_Update_Params
comment  3737
label    3737 Load_Obj_UDG_RAM_Addr_Size_V_1
comment  373D
comment  373D Store object UDG Addr from Y and A into ZP0E & 0F, minus $100
comment  373D Valuables, Platforms etc.
label    373D Load_Obj_UDG_RAM_Addr_Size_V
comment  3743
comment  3743 Store object position in ZP04 & 05
comment  374B
comment  374B Convert object position XY pixel coordinates to UDG RAM address, managing X axis wrap.
comment  374B Loads screen-wrap byte from current UDG Data animation frame, it's set to 8 if next frame
comment  374B will move object into next UDG RAM column.
deflabel 3753 SCREEN_WIDTH_PIXELS
deflabel 3758 SCREEN_WIDTH_PIXELS
label    3759 No_X_Wrap_
comment  3760
comment  3760 ZP04/05 are now an address instead of X and Y coordinates.
comment  3760 Subtract $FF from 16-bit UDG_RAM Address for indexing with Y after.
deflabel 3764 UDG_DATA_HEIGHT_PIXELS_OFFSET
comment  376D
comment  376D Get/store object width in characters (zero-based i.e. 0 is 1 byte wide)
deflabel 376E UDG_DATA_WIDTH_BYTES_OFFSET
comment  3775
comment  3775 Get/store object height in pixels (one-based i.e. 9 is 9 pixels high)
comment  377C
comment  377C Subtract $03 from 16-bit object UDG Data addrress, i.e. so address
comment  377C avoids the object dimension bytes
deflabel 3780 UDG_DATA_BITMAP_OFFSET
comment  3783
comment  378A
label    378A Load_Obj_UDG_RAM_Addr_Size_JM1
lcomment 378A Returns UDG Addr Lo in Y, Hi in A
comment  378D
comment  378D Store object UDG Addr from Y and A into ZP06 & 07, minus $100
comment  378D Jetman, Rocket Modules, Aliens
comment  378D Rocket Middle Section Object UDG RAM Position A=3C, Y=F7, thus $3CF7
label    378D Load_Obj_UDG_RAM_Addr_Size_JM
lcomment 3791 ZP07/06=$3BF7
comment  3793
comment  3793 Store object position in ZP04 & 05
comment  379B
comment  379B Convert object position XY pixel coordinates to UDG RAM address, managing X axis wrap.
comment  379B Loads screen-wrap byte from current UDG Data animation frame, it's set to 8 if next frame
comment  379B will move object into next UDG RAM column.
lcomment 3799 ZP04=X=$50 ZP05=Y=$5F
deflabel 37A3 SCREEN_WIDTH_PIXELS
deflabel 37A8 SCREEN_WIDTH_PIXELS
label    37A9 No_X_Wrap
lcomment 37A9 ZP04=X=$50 ZP05=Y=$5F
lcomment 37AB ZP05/04=$173F i.e. rocket middle
lcomment 37AB section start position
comment  37AE
comment  37AE ZP04/05 are now an address instead of X and Y coordinates.
comment  37AE Subtract $FF from 16-bit UDG_RAM Address for indexing with Y after.
deflabel 37B2 UDG_DATA_HEIGHT_PIXELS_OFFSET
comment  37BB
comment  37BB Get/store object width in characters (zero-based i.e. 0 is 1 byte wide)
deflabel 37BC UDG_DATA_WIDTH_BYTES_OFFSET
comment  37C1
comment  37C1 Get/store object height in pixels (one-based i.e. 9 is 9 pixels high)
comment  37C6
comment  37C6 Subtract $03 from 16-bit object UDG Data addrress, i.e. so address
comment  37C6 avoids the object dimension bytes
deflabel 37CA UDG_DATA_BITMAP_OFFSET
comment  37CD
comment  37D4
comment  37D4 Aliens Types: 05=Fuzzball, 06=Saucer, 07=Ball, 08=Cross
comment  37D4 All Aliens have only 2 animation states
comment  37D4 InReg: A=Object Type (Alien), X=Animation Frame
comment  37D4 OutReg: A=UDG Addr Hi, Y=UDG Addr Lo
label    37D4 Get_Obj_UDG_Data_Addr_Alien
comment  37D6
comment  37D6 Convert object's screen X position to 0 or 2 byte animation frame data offset & put back into X
lcomment 37D7 Zero bits 0 & 2-7
binary   37D8
comment  37DB
comment  37DB Transform Object Types 5/6/7/8 to 2/3/4/5, then multiply by 4 to get the frame data offset offset
comment  37DB Note, starting with offset 2 instead of 0 means 4 wasted bytes in the data address table
comment  37E0
comment  37E0 Add $20 offset, which takes us to the start of the Alien UDG data, past Jetman UDG data
comment  37E6
comment  37E6 Alternate entry point to routine using different ZP vars for object Position and Type
label    37E6 Get_Obj_UDG_Data_Addr_JM_Ali_1
lcomment 37E8 Zero bits
bin      37E9
comment  37ED
comment  37ED When object is Jetman, Object Type represents State i.e. Flying/Standing, Facing Left/Right, Frame.
comment  37ED There are 16 Jetman animation frames, 4 Fly Right, 4 Fly Left, 4 Stand Left, 4 Stand Right,
comment  37ED in that order, in a list of 16-bit address to the UDG data.
comment  37ED This routine uses bit 7 of the Jetman Object Type to select Right or Left and bit 0 to
comment  37ED select Flying or Standing, when creating an offset in register X.
comment  37ED InReg: A=Object Type (Jetman), X=Animation Frame
comment  37ED OutReg: A=UDG Addr Hi, Y=UDG Addr Lo
label    37ED Get_Obj_UDG_Data_Addr_JM_Alien
comment  37EE
comment  37EE Jetman uses only bit 7 (direction he's facing) and bits 0 & 1 (standing/flying).
comment  37EE If other bits are used, object must be an Alien.
lcomment 37EE Zero bits 6 & 7
binary   37EF
lcomment 37f0 Test bits 0 & 1
binary   37F1
lcomment 37F2 Carry Set if A >= compared value
comment  37F5
comment  37F5 Object is Jetman, test state, is he looking Left or Right?
comment  37FA
comment  37FA Jetman is looking left, set bit 3 in X, which adds $08 to the UDG data address, meaning
comment  37FA that it will point to the Jetman facing Left UDG data addresses instead of facing Right.
lcomment 37FC Set bit 3
binary   37Fd
comment  3800
comment  3800 A contains Jetman State, bit 7 is Direction-faced. SEC & SBC prepare ASLs to move bit 7 to bit 3
comment  3800 This effectively adds $10 to the calculated UDG data address when Jetman is Standing,
comment  3800 meaning it points to the Jetman Standing data addresses instead of Jetman Flying.
label    3800 Get_Obj_UDG_Data_Addr_Calc_JM
comment  3807
comment  3807 OR A and X together to produce full UDG data table offset
label    3807 Get_Obj_UDG_Data_Addr_Calc
comment  380D
comment  380D Using X just set, get index into the Object UDG table
lcomment 380D Address lo byte into Y
lcomment 3811 Address hi byte into A
comment  3815
comment  3815 Get address of UDG Data for Jetman or Alien objects and return in A and Y registers
comment  3815 Bits 1 & 2 of object's X position used to select UDG animation frame.
comment  3815 Animations have 2 or 4 frames and are minimum 2 pixels apart so bit 0 not used.
label    3815 Get_Obj_UDG_Data_Addr_JM_Ali_2
lcomment 3817 Reset bits 0 & 3-7
binary   3818
comment  381F
label    381F Colourize_Object
comment  3827
comment  3827 Setup Colour RAM params based on object position X & Y via ZP04/ZP05 e.g. Rocket Top X=20, Y=3F
comment  382A
comment  382A Divide object height by $10 then add $02, so always update colour on at least two vertical tiles
comment  382A e.g. Jetman=$18->$03, Rocket_Top=$10->$03, Fuzz_Alien=$0A->$02
comment  3833
comment  3833 Use ZP0B as outer loop for vertical tile rows
comment  3835
comment  3835 Use ZP0A as inner loop for horizontal tile columns
label    383B Loop_Y
comment  383F
comment  383F Read colour from RAM and if it's green i.e. colour of the platforms, skip the colour change
comment  383F else write the updated colour to the colour RAM
label    383F Loop_X
lcomment 3841 Zero bits 3-7
binary   3842
deflabel 3844 COLOUR_GREEN
comment  3847
comment  384B
label    384B Green_Ignored
comment  384F
comment  384F Move to next row to colour (i.e. move up) and test for going out of
comment  384F screen boundry at top of screen, early exit if so
deflabel 3853 SCREEN_WIDTH_COLUMNS
deflabel 3855 SCREEN_WIDTH_COLUMNS
comment  3858
comment  3858 Update the Colour RAM for the appropriate tile, move up one row
comment  385E
label    385E Colourize_Object_RTS
;
; End of file contains graphics data
;
;unused   3861-3fff ; TEMP STOP THE OUTPUT OF THE GRAPHICS
comment  385F
label    385F UDG_Data_Jetman_Aliens
break    385F-3FFF ; Output one byte per line
word     385F-3896
label    3860 UDG_Data_Jetman_Aliens+1
lcomment 3865 $3C87 = Jetman_Fly_Right_3
;
; Objects and UDG start here
;
comment  3897
binary   3897-3C86
word     3C87-3C88
const    3C87-3C88
word     3C89-3CB0
binary   3CB1-3FFF
;
label    38CA Jetman_Fly_Left_3
label    38FD Jetman_Walk_Left_3
label    3930 Jetman_Walk_Left_2
label    397B Jetman_Walk_Left_1
label    39C6 Jetman_Walk_Left_0
label    39F9 Jetman_Walk_Right_0
label    3A2C Jetman_Walk_Right_1
label    3A77 Jetman_Walk_Right_2
label    3AC2 Jetman_Walk_Right_3
label    3AF5 Jetman_Fly_Left_2
label    3B40 Jetman_Fly_Left_1
label    3B8B Jetman_Fly_Left_0
label    3BBE Jetman_Fly_Right_0
label    3BF1 Jetman_Fly_Right_1
label    3C3C Jetman_Fly_Right_2
comment  3C87 $3C87 = Jetman_Fly_Right_3, it's referenced after the end of the object's data
comment  3C87
label    3C87 UDG_Data_Ship_Fuel_Valuables
label    3C88 UDG_Data_Ship_Fuel_Valuables+1
lcomment 3C9F Multiple entries for UDG objects indexing based on player wave
label    3E46 Alien_Ship_1
label    3E61 Alien_Ship_2
label    3E78 Alien_Fuzz_1
label    3E99 Alien_Fuzz_2
label    3EB8 Alien_Bubble_1
label    3EEB Alien_Bubble_2
label    3F0E Alien_Cross_1
label    3F41 Alien_Cross_2
label    3CD4 Ship_1_Bott
label    3CF7 Ship_1_Mid
label    3D1A Ship_1_Top
label    3D3D Ship_2_Bott
label    3D60 Ship_2_Mid
label    3D83 Ship_2_Top
label    3D9C Fuel_Cell
label    3DAF Gold_Bar
label    3DCA Gemstone
label    3DE3 Plutonium
label    3E00 Isotope
label    3E15 Mineral
label    3F74 Explosion_UDG_RAM_Addr_Frame_1
label    3F9B Explosion_UDG_RAM_Addr_Frame_2
label    3FB2 Explosion_UDG_RAM_Addr_Frame_3
; End of File