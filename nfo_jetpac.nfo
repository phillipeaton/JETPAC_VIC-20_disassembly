insert ; ----------------------------------------------------------
insert ;  This is the reverse-engineered source code for the
insert ;  game 'JETPAC' written by Ultimate Play The Game.
insert ; ----------------------------------------------------------
insert
;
; Start of disassembly instructions
word     2000-2003
comment  2004
comment  2004 Initial value table for VIC setup 16 bytes
label    2004 VIC_Init_Tab
lcomment 2004 VIC_R0_H_Ctr     Left edge of TV picture and interlace switch.
const    2004-201B
break    2004-2013
lcomment 2005 VIC_R1_V_Ctr
lcomment 2006 VIC_R2_Num_Cols
lcomment 2007 VIC_R3_Num_Rows
lcomment 2008 VIC_R4_TV_Raster
lcomment 2009 VIC_R5_CM_Start
lcomment 200A VIC_R6_H_LightP
lcomment 200B VIC_R7_V_LightP
lcomment 200C VIC_R8_Paddle_X
lcomment 200D VIC_R9_Paddle_Y
lcomment 200E VIC_RA_Frq_Osc1
lcomment 200F VIC_RB_Frq_Osc2
lcomment 2010 VIC_RC_Frq_Osc3
lcomment 2011 VIC_RD_Frq_Noise
lcomment 2012 VIC_RE_Vol_Color
lcomment 2013 VIC_RF_BckBdrCol
comment  2014
comment  2014 Quick lookup for BIT instruction
label    2014 MASK_00000001
binary   2014-201B
label    2015 MASK_00000010
label    2016 MASK_00000100
label    2017 MASK_00001000
label    2018 MASK_00010000
label    2019 MASK_00100000
label    201A MASK_01000000
label    201B MASK_10000000
comment  201C
comment  201C +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     201C NMI_Interrupt_Hardler
comment  201D
comment  201D ----------------------------------------------------------
comment  201D Starts here
comment  201D ----------------------------------------------------------
lcomment 201D Disable Interrupts
lcomment 201E Reset stack pointer
lcomment 2021 Clear Decimal flag
comment  2022
comment  2022 Setup NMI interrupt vector to service routine at $201C
comment  202C
comment  2032
comment  2032 Setup I/O data direction and interrupt enables
comment  2041
comment  2044
comment  2044 Set VIA outputs for keyboard scan
lcomment 2046 Data I/O register (User port & RS-232) i.e. not used
lcomment 2049 Data I/O register (Keybd col scan, Cassette, Joy)
comment  204C
comment  204C Setup IRQ interrupt vector to service routine at $25E0
comment  2056
comment  2056 Reset the VIC registers
lcomment 2056 16 registers
label    2058 Reset_VIC
comment  2061
comment  2061 Initialize Screen RAM i.e. map screen tiles to User-Defined Graphics RAM
comment  2061 Each character is a 16x8 tile i.e. double height, thus play area
comment  2061 is decimal 11 Rows x 23 Columns
comment  2061 0200  00 0B 16 21 2C 37 42 4D 58 63 6E 79 84 8F 9A A5 B0 BB C6 D1 DC E7 F2
comment  2061 0217  01 0C 17 22 2D 38 43 4E 59 64 6F 7A 85 90 9B A6 B1 BC C7 D2 DD E8 F3
comment  2061 022E  02 0D 18 23 2E 39 44 4F 5A 65 70 7B 86 91 9C A7 B2 BD C8 D3 DE E9 F4
comment  2061 0245  03 0E 19 24 2F 3A 45 50 5B 66 71 7C 87 92 9D A8 B3 BE C9 D4 DF EA F5
comment  2061 025C  04 0F 1A 25 30 3B 46 51 5C 67 72 7D 88 93 9E A9 B4 BF CA D5 E0 EB F6
comment  2061 0273  05 10 1B 26 31 3C 47 52 5D 68 73 7E 89 94 9F AA B5 C0 CB D6 E1 EC F7
comment  2061 028A  06 11 1C 27 32 3D 48 53 5E 69 74 7F 8A 95 A0 AB B6 C1 CC D7 E2 ED F8
comment  2061 02A1  07 12 1D 28 33 3E 49 54 5F 6A 75 80 8B 96 A1 AC B7 C2 CD D8 E3 EE F9
comment  2061 02B8  08 13 1E 29 34 3F 4A 55 60 6B 76 81 8C 97 A2 AD B8 C3 CE D9 E4 EF FA
comment  2061 02CF  09 14 1F 2A 35 40 4B 56 61 6C 77 82 8D 98 A3 AE B9 C4 CF DA E5 F0 FB
comment  2061 02E6  0A 15 20 2B 36 41 4C 57 62 6D 78 83 8E 99 A4 AF BA C5 D0 DB E6 F1 FC
label    2064 ISR_Cols
deflabel 2065 COLUMNS
label    2067 ISR_Rows
deflabel 206C ROWS
deflabel 2076 ROWS
comment  2079
label    2079 Reset_Game_Select
comment  207C
comment  207C Reset game selection flashing highlights
label    2080 RGS_Flash
comment  2085
comment  2085 Setup volume and color
comment  208A
comment  208A Disable sound object
comment  208F
comment  208F ----------------------------------------------------------
comment  208F Game Select Loop
comment  208F ----------------------------------------------------------
label    208F Game_Select
lcomment 2093 Set Port B all bits to input
lcomment 2098 Set Port A all bits to output
comment  209B
lcomment 209B Select keyboard column to read
lcomment 209D \ (F7/F5/F3/F1/CDown/CRight/Rtn/Del)
lcomment 20A0 Whilst giving keyboard data time to settle?
lcomment 20A3 Read keyboard column
lcomment 20A6 Store keyboard data
comment  20A8
comment  20A8 Test F-Keys pressed or Space to start game
lcomment 20AA F1 pressed? (1 Player)
lcomment 20AC No, skip
lcomment 20AF Reset Bit0 = 1 Player
comment  20B2
label    20B2 Test_F3
lcomment 20B4 F3 pressed? (2 Player)
lcomment 20B6 No, skip
lcomment 20B9 Set Bit0 = 2 Player
comment  20BC
label    20BC Test_F5
lcomment 20BE F5 pressed? (Keyboard)
lcomment 20C0 No, skip
lcomment 20C3 Reset Bit1 = Keyboard controls
comment  20C6
label    20C6 Test_F7
lcomment 20C8 F7 pressed? (Joystick)
lcomment 20CA No, skip
lcomment 20CD Set Bit1 = Joystick controls
comment  20D0
comment  20D0 Store options, update display and test for game start
label    20D0 Test_Space
lcomment 20D0 Save game settings
lcomment 20D1 0=1P+Kbd, 1=2P+Kbd, 2=1P+Jsk, 3=2P+Jsk
comment  20D7
lcomment 20D9 Select keyboard column to read
lcomment 20DC \ (2/Q/CBM/Space/Stop/Ctrl/Left/1)
lcomment 20DF Space Pressed?
lcomment 20E1 No, check for settings again
comment  20E3
comment  20E9
comment  20E9 ----------------------------------------------------------
comment  20E9 FUNCTION  : Update_Laser_Objects
comment  20E9 CALLED BY :
comment  20E9 CALLS     : Nothing
comment  20E9 ARGUMENTS : sentiseutn
comment  20E9 \            etinseut
comment  20E9 \            setniseutn
comment  20E9 ----------------------------------------------------------
label    20E9 Update_Laser_Objects
lcomment 20EB Update once every four calls
comment  20F0
label    20F0 Update_Laser_Objects_1
const    20F3
lcomment 20F4
word     20F4
const    20F6
comment  20F7
comment  20F7 Loop through the four possible Laser shots, branch if any are zero I.E. NOT SHOOTING???????
label    20FB Update_Laser_Objects_2
comment  20FF
comment  20FF Move ZP index address to next 8 bytes i.e. next Laser shot
label    2110 Update_Laser_Object
lcomment 2110 Get Jetman attrib 00 i.e. fly/no-fly and facing left/right and ???
lcomment 2112 Store for later
lcomment 2113 Jetman looking left?
lcomment 2115 Set bit 4, DON'T KNOW WHAT IT'S USED FOR??????????
lcomment 2117 Store to inactive Laser attrib 00
comment  2119
lcomment 2119 Move to next Jetman attrib 01
lcomment 211A Get Jetman attrib 01 i.e. X position
lcomment 211C Zero the bottom 3 bits
lcomment 211E Set bits 0 & 2
lcomment 2120 Store for later
comment  2122
lcomment 2122 Restore Jetman attrib 00
lcomment 2123 Jetman looking left?
lcomment 2125 No, branch
label    212f Update_Laser_Object_1
comment  213C
label    2145 Update_Laser_Object_2
comment  214B
comment  2155
comment  2155 Load a random laser color using the current 6522 timer value
comment  2160
comment  2160 Trigger laser sound
comment  216B
label    216B Laser_Color_Table
lcomment 216B Green not used, messes up colors if it's used
deflabel 216B WHITE
deflabel 216C RED
deflabel 216D CYAN
deflabel 216E PURPLE
deflabel 216F BLUE
break    216F
deflabel 2170 YELLOW
deflabel 2171 CYAN
deflabel 2172 YELLOW
comment  2173
label    2173 Laser_Jetman_Facing_Right
lcomment 2173 Get Jetman attrib 01 i.e. ????????
lcomment 2175 Zero bits 3-7, any bits 0-2 set?
lcomment 2177 No, branch
label    217E Laser_Jetman_Facing_Right_1
lcomment 217E Zero bit 0
lcomment 2180 TESING AT EDGE OF SCREEN?
label    2187 Laser_Jetman_Facing_Right_2
lcomment 2188 OFFSETTING EDGE OF SCREEN?
label    218D Laser_Jetman_Facing_Right_3
lcomment 218D Restore saved Jetman attrib 00
lcomment 2190 Add $10 for some reason??????????
comment  2195
label    2195 Fire_Pressed_0
label    219A DISPLAY_LASERS
lcomment 219A ???????
lcomment 21A0 Y=$07, laser color addr
lcomment 21A1 Fetch laser color
lcomment 21A3 Store to ZP variable
comment  21A5
comment  21A5 Get laser X and Y-coord and store to temp vars
lcomment 21A5 Y=$02, X-coord of laser horizontal end point
lcomment 21AD Y=$01, Y-coord of laser
comment  21B4
comment  21B4 Test if X-coord of laser is on a #16 boundary, update tile colour ######## NEEDS CONFIRM
comment  21C1
comment  21C1 Test if X-coord of laser is on a boundary and wrap if necessary ######## NEEDS CONFIRM
comment  21CB
label    21CB FP1111
lcomment 21CE Save A
lcomment 21D1 Get Y Coord
lcomment 21D4 Test Y coord bit 7 ???
lcomment 21D8 Get X Coord
label    21DC FP2222
lcomment 21DC Restore A
comment  21DD
comment  21DF
comment  21DF Invert the displayed 8-bit byte on-screen
comment  21E5
comment  21E5 Load current tile color, check it's not green, if not update tile color
lcomment 21E5 ZP0C_Col_RAM_Ptr_Lo
lcomment 21E7 Zero top 4 bits
lcomment 21E9 Test if 0101
deflabel 21EA GREEN
lcomment 21ED Tile color
lcomment 21EF ZP0C_Col_RAM_Ptr_Lo
comment  21F1
comment  21F1 Some kind of screen wrap?
label    21F1 FP3333
label    21FC FP4444
comment  2202
comment  2202 Loads ZP 14/15/16/17 with seed values, which are something to do with the four lasers
label    2202 FP5555
lcomment 2205 ZP_0A_Lo/Hi
break    2206
lcomment 2208 ZP_0B_Lo/Hi
break    2208
break    2209
lcomment 220B ZP_01_Lo/Hi
break    220B
break    220C
break    220E
comment  220F
comment  220F Iterate round each of the laser shots that could be active for display
label    2211 FP6666
lcomment 2211 First time round, Y=3, next time 4 and so on
lcomment 2212 Get one of the four laser object paramenters
lcomment 2216 Zero bottom 3 bits, probably testing if laser shot ended
lcomment 221D Active laser shots counter at zero?
lcomment 221F No, process next laser shot
comment  2221
comment  2221 All laser shows ended, zero laser shots object type
comment  2229
comment  2229 Process laser shot, update parameters in object table
label    2229 FP7777
lcomment 2229 Get one of the four laser object paramenters
lcomment 223A Zero bit top 6 bits
lcomment 223C Set bit 2, now is 000001xx
lcomment 2244 Set bit 2
comment  2248
comment  2248 Update object list parameteters from ZP temp vars
label    2248 FP8888
comment  224E
comment  2254
comment  2257 Get X-coord from object list parameters and Y-coord, store to UDG RAM address pointers and
label    2257 FP9999
label    2263 FPAAAA
comment  226C
comment  226C EXOR-write data in ZP variable to UDG RAM
lcomment 226C Save Y
lcomment 227D Restore Y
comment  227E
lcomment 2280 Iterate to next laser shot
lcomment 2282 Update object list and exit subroutine
label    2285 CLC_ADC_08
label    228B Laser_ZP17_15_to_ZP16_14
comment  2298 Looks like it's doing some checks on the X coord, e.g. laser wraparound
label    2298 Laser_Wrap?
lcomment 229B $B8=screen width in pixels
label    22A1 Laser_Wrap_1?
lcomment 22A1 Save Y on Stack
lcomment 22A5 Get object's type/direction byte
lcomment 22A7 Test Bit 7 is set i.e. towards left
lcomment 22AA No, branch
lcomment 22AC Restore Y from Stack
comment  22AE
lcomment 22AF Zero the top 5 bits
lcomment 22B1 Set bits 7,5,4, now it's 1011 0xxx
comment  22B4 Towards right
label    22B4 Laser_JFL_2
lcomment 22B4 Restore Y from Stack
comment  22B6
lcomment 22B7 Zero the top 5 bits
comment  22BA
label    22BA Reset_Level_Add_Extra_Life
comment  22BD
comment  22BD Player at level 4, add another life
label    22CB Reset_Lev_Add_Extra_Life_1
comment  22D1
label    22D1 Reset_Lev_Add_Extra_Life_2
comment  22D7
label    22D7 Reset_Lev_Add_Extra_Life_3
comment  22E3
label    22E3 Set_Obj_List_Type_Rocket_Fuel
word     22EA
label    22ED JMP_Reset_S_O_1
break    22ED
comment  22F2
label    22F2 Object_RMS_Gem_Type
word     22F9
label    22FF Init_Objects_1_To_3
label    2301 CBTSR1
label    230B Reset_Some_Objects
word     2315
label    231A Reset_S_O_1
label    233B Inital_Screen_Object_Data
lcomment 233B $09=Rocket Bottom Section, $70=X, $AF=Y
const    233B-235A
lcomment 233F ???
break    233F
comment  2343
lcomment 2343 $04=Rocket Top Section, $20=X, $3F=Y
break    2343
lcomment 2347 ???
break    2347
comment  234B
lcomment 234B $04=Rocket Middle Section, $50=X, $5F=Y
lcomment 234F ???
break    234F
comment  2353
label    2353 Initial_Jetman_Obj_Params
lcomment 2353 Image, X, Move Speed, Y
lcomment 2357 Movement, ?, ?, ?
break    2357
comment  235B
label    235B Init_Next_Jetman_Lives_Scores
lcomment 235B Loop through 8 attributes
label    235D LOOP_INJLS_1
comment  2366
lcomment 2366 More time between players when 2 player game
lcomment 2369 One player game?
lcomment 236B Yes, jump
lcomment 236D Set countdown for 2 player game
label    236F LDA_7F_Return
lcomment 236F Store countdown
comment  2373
label    2373 Display_P1_Lives
lcomment 2376 ZP Offset for 1st address
const    2376
lcomment 2377 1st Address
word     2377
comment  2382
label    2382 Display_P2_Lives
lcomment 2385 ZP Offset for 1st address
const    2385
lcomment 2386 1st Address
word     2386
comment  238E
label    238E Display_Number_Lives
lcomment 238F $70 = "0" character
comment  2396
comment  2396 Display Jetman Icon next to number of lives
word     239A
lcomment 239D 8 bytes of UDG data to copy
label    23A2 Zero_Lives_To_UDG_RAM_1
label    23A8 Zero_Lives_To_UDG_RAM
lcomment 23A8 $60 = Space character
lcomment 23AF $60 = Space character
label    23B6 Load_Num_Lives
label    23BA Load_Num_Lives_P1
label    23BD Load_Num_Lives_P2
label    23C0 Load_Num_Lives_Inverse
label    23C7 Jetman_Icon
lcomment 23C7 ...##...
const    23C7-23CE
bin      23C7-23CE
break    23C7-23CE
lcomment 23C8 ..#..#..
lcomment 23C9 ..####..
lcomment 23CA .######.
lcomment 23CB .#.##.#.
lcomment 23CC ..####..
lcomment 23CD ..####..
lcomment 23CE .##..##.
comment  23CF
label    23CF LDA_7F
comment  23D4
label    23D4 Setup_Player_Lives
label    23D6 BACK_SPL
comment  23DA
comment  23E7
label    23F4 SKIP_SPL
label    23F5 Swap_Player_And_Objects
label    23F7 Swap_Player
comment  2404
label    2406 Swap_Object
comment  2416
label    2416 Reset_Screen_Disp_Scores
lcomment 241C Puts 000000  000000  00 at top of screen
comment  2425
comment  2425 Setup address to copy data from ($2450) into UDG array for 1UP HI 2UP
label    2425 Display_1UP_HI_2UP_Titles
lcomment 2427 3 strings to display, 1UP, HI and 2UP
label    2429 BACK_D1H2
comment  2441
comment  244C
label    2450 STR_1UP
label    2457 STR_HI
break    2457
label    245E STR_2UP
break    245E
comment  2465
label    2465 STR_1UP_HI_2UP
lcomment 2465 X Y
word     2467
lcomment 2469 X Y
const    2469
word     246B
lcomment 246D X Y
word     246F
comment  2471
label    2471 Display_P1_Score
lcomment 2474 ZP_UDG_RAM_X ZP_UDG_RAM_Y, but not in this case
lcomment 2475 UDG array absolute position to display score at
word     2475
lcomment 2477 ZP_Ptr_To_Str
lcomment 2478 Players score in ZP as BCD e.g. 12 34 56
word     2478
lcomment 247A ZP_Temp_1
lcomment 247B 3 bytes of BCD data to display e.g. 12 34 56
word     247B
const    247B
label    2481 Display_P2_Score
lcomment 2484
const    2484
lcomment 2485
word     2485
lcomment 2487
const    2487
lcomment 2488
word     2488
lcomment 248A
const    248A
lcomment 248B
word     248B
const    248B
break    248D
label    2491 Display_Hi_Score
lcomment 2494
const    2494
lcomment 2495
word     2495
lcomment 2497
const    2497
lcomment 2498
word     2498
lcomment 249A
const    249A
lcomment 249B
word     249B
const    249B
break    249D
label    24A1 Game_Sel_Flash_Period
label    24A4 GSFP1
lcomment 24A5 Test settings bit 1, if not set, skip counter logic
lcomment 24A9 Counter for flash period
lcomment 24AB remove the lasers? and flashes get faster
label    24B2 GSFP2
comment  24B9
label    24B9 Display_Game_Select
comment  24CA
lcomment 24CD ZP_UDG_RAM_X
lcomment 24CE X Y
break    24CE
const    24CF
break    24D0
word     24D1
comment  24D7
lcomment 24DA ZP_UDG_RAM_X
lcomment 24DB X Y
break    24DB
break    24DD
word     24DE
comment  24E4
lcomment 24E7 ZP_Ptr_To_Str
lcomment 24E8 String address
word     24E8
comment  24EB
label    24EF DGS1
comment  2500
label    251F Fn_Key_SP_Row_Offsets
const    251F-2523
comment  2524
label    2524 STRING_COPYRIGHT_1983_ACG
lcomment 2539 Top bit=1 indicates end of string
lcomment 2539 `= Space, qyxs = 1983, n=.
label    253A STR_JETPAC_GAME_SELECT
label    2550 STR_F1_1_PLAYER_GAME
label    2562 STR_F3_2_PLAYER_GAME
label    2574 STR_F5_KEYBOARD
label    2581 STR_F7_JOYSTICK
label    258E STR_SP_START_GAME
comment  259D
label    259D Load_ZP_Parameters
lcomment 259D
lcomment 259D Parameters for this routine are assembled into ROM after the
lcomment 259D call to this routine and accessed via the return address
lcomment 259D stored on the stack.
lcomment 259E Stash return address
comment  25A3
label    25A5 LZPP_1
lcomment 25A5 Load next parameter value, ZP address for next param else $FF
lcomment 25A7 Value $FF?
lcomment 25A9 If No, Skip
comment  25AE
label    25B5 Load_ZP_Parameter
lcomment 25B5 Stash to X number before string characters (string len?)
comment  25B6
lcomment 25B6 Address starts at end of previous opcode operand, so inc it
lcomment 25B9 Y starts at 1
lcomment 25BB Store the parameter value to requried ZP address lo-byte
comment  25BD
lcomment 25BD Same again for hi-byte
comment  25C4
lcomment 25C4 Move to next parameter
lcomment 25C7 Go back and read the next parameter
label    25CA Inc_Param_Addr
lcomment 25CA Inc address at $40, inc lo-byte, then hi-byte if lo-byte=0
label    25D0 IPA1
comment  25D1
label    25D1 Game_Start
comment  25E0
comment  25E0 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     25E0 Hardware_Interrupt_Handler
lcomment 25E4 Reset VIA2 timer
label    25F4 HIH_1
comment  25FA
comment  25FA ----------------------------------------------------------
comment  25FA Game Main Loop
comment  25FA ----------------------------------------------------------
label    25FA Main_Loop_Object_0
lcomment 25FE $03B0 = "Object_0"
lcomment 2606 Enable interrupts
label    2607 Main_Loop
lcomment 2609 Load Object Type into A from obj table 0380 upwards
lcomment 260B Mulitply by two as 2 bytes in an address
lcomment 260C Object Type becomes offset into Subroutine List
lcomment 260D Load SR List offset into SR Vec Lo/Hi...
lcomment 2617 ...and jump to it
comment  261A
label    261A GOTO_NEXT_OBJECT
lcomment 261C Test Object Type value
lcomment 261E If <>00, skip
comment  2620
comment  2620 Test if object is a rocket module
lcomment 2622 Is Object address $B0?
lcomment 2624 If not, skip
comment  2626
comment  2626 Delay loop
comment  2626 $100 x $02 x (2+3) = $A00 = 2,560 cycles @ 1.108MHz PAL = 0.02 Seconds
label    262A Delay_Loop_0A00
comment  2630
comment  2630 Increment Object Pointer to next Obj i.e. by adding 8
label    2630 Inc_Object_List_Ptr
comment  2637
comment  2637 If interrupt happened, update Jetman, it has higher priority
lcomment 2637 H/W interrupt happened?
lcomment 2639 If yes, jump
comment  263B
label    263B Main_Loop_Continue
lcomment 263D Is Object address a rocket module?
comment  2645
comment  264B
comment  2652
comment  2652 Test if score flash time is zero, if yes, setup objects
label    2652 Test_Score_Flash_Time_At_Zero
comment  2655
label    2655 Spawn_Objects
comment  265E
comment  265E ----------------------------------------------------------
comment  265E VIA2 timer interrupts used to update Jetman movement
comment  265E $4FD7 / 1.108Mhz = 54.2Hz interrupt. Screen is 184 pixels
comment  265E wide. At one pixel walking movement pet interrupt, Jetman
comment  265E should get across the screen in about 3.5 seconds.
comment  265E ----------------------------------------------------------
label    265E Set_Jetman_Mvmt_Speed
comment  2669
label    2669 SEI_Obj_Ptr_To_Jetman
lcomment 2669 Set Disable Interrupts flag
comment  266E
comment  2676
lcomment 2679 ZP Offset for 1st address
const    2679
lcomment 267A 1st Address
word     267A
comment  2680
label    2680 Restore_Obj_Ptr_CLI
lcomment 2688 Clear Disable Interrupts flag
comment  268C
label    268C Subroutine_List
lcomment 268C 00
word     268C-26AD
label    268D Subroutine_List+1
lcomment 268E 01
lcomment 2690 02
lcomment 2692 03
lcomment 2694 04
lcomment 2696 05
lcomment 2698 06
lcomment 269A 07
lcomment 269C 08
lcomment 269E 09
lcomment 26A0 0A
lcomment 26A2 0B
lcomment 26A4 0C
lcomment 26A6 0D
lcomment 26A8 0E
lcomment 26AA 0F
lcomment 26AC 10
comment  26AE
label    26AE Initialize_Sound_Object
label    26B0 Initialize_Sound_Object_1
comment  26B9
comment  26B9 Initialize sound channels
comment  26C5
label    26C5 Init_Sound_Object_Table
break    26C9
comment  26CD
comment  26CD Read and play sound channel data from the Sound object
label    26CD SOUND_UPDATE
comment  26D1
comment  26D1 Uses the Subroutine_Addr_Hi as an index, a bit confusing to read...oh well
comment  26D1 1st/3rd/5th parameter indicates which sound to play, 2/4/6 is the period
label    26D1 Sound_Loop
comment  26D7
comment  26D7 Jump to Sound player using X as jump table index
comment  26E4
comment  26E4 Update index to next 2-byte oscillator/timer pair, stopping when
comment  26E4 all 3 processed i.e. at 7th parameter. Sound 0 is valid
comment  26E4 but 'empty' sound call.
label    26E4 Goto_Next_Sound
comment  26F2
comment  26F2 Decrements Oscillator channel timer stored in ZP index
comment  26F2 Index points to Oscillator number, so increment to address timer value
comment  26F2 Timer value left in A, counts down to zero
label    26F2 Decrement_Oscillator_Timer
comment  26F6
comment  26F6 Read timer, subtract 1 and write back
comment  26FE
label    26FE Rocket_Part_or_Fuel_Cell_PickUp
comment  2703
comment  2703 Inverts the timer value so $10 countdown becomes $F0, F1, F2 etc. stored
comment  2703 to the oscillator on subsequent calls, making a pleasent short rising tone
comment  2705
comment  2705 Set top bit of oscillator channel to enable
label    2705 Enable_Oscillator_Channel
binary   2706
comment  270A
comment  270A When oscillator timer expired, delete the oscillator parameter to disable
label    270A Sound_Done_Reset_Object_Param
comment  2710
comment  2710 Register A contains frequency, Y selects channel via X
label    2710 Output_Sound
comment  2716
comment  271C
label    271C Valuable_Pkup_Rocket_Part_Lands
comment  2721
comment  2721 Manipulate timer to make a nice sound
comment  2727
label    2727 Laser_Beam_Active
comment  272C
comment  272C Manipulate timer to make a nice sound
comment  2735
label    2735 Rocket_Flight
comment  273A
comment  273A Utilise rocket object height to manipulate noise sound channel
comment  2743
label    2743 Subroutine_Sound_Jump_Table
lcomment 2743 00
word     2743-274D
label    2744 Subroutine_Sound_Jump_Table+1
lcomment 2745 01
lcomment 2747 02
lcomment 2749 03
lcomment 274B 04
lcomment 274D 05
comment  274F
label    274F Collision_Explosion
comment  2754
comment  2754 Manipulate timer to make an explosion sound, though doesn't use noise
comment  275B
comment  275B Erase $100 bytes zero page
label    275B Erase_ZP_RAM
label    275E Erase_ZP_RAM_1
label    2764 Erase_Object_RAM
label    2768 Erase_Object_RAM_1
comment  276F Erase $30 bytes at end of UDGs $1fd0-$2000
label    276F Erase_HiScore_Setts_Etc
label    2773 Erase_HiScore_Setts_Etc_1
comment  277A
label    277A Check_New_Hi_Score
lcomment 277D ZP_00
const    277D
lcomment 277E Addr of High Score value
word     277E
lcomment 2780 ZP_08
const    2780
lcomment 2781 Addr of P1 High Score value
word     2781
comment  2784
lcomment 2784 Check Player 1 first
comment  2787
lcomment 2787  then follow through for Player 2
lcomment 278A ZP_08
const    278A
lcomment 278B Addr of P2 High Score value
word     278B
comment  278E
comment  278E Compare Hi Score BCD bytes
label    278E Test_New_Hi_Score
label    2790 Compare_BCD_Byte
lcomment 2796 Branch if SCORE_HI < Player Score
lcomment 2798 SCORE_HI >= Player Score, so return
label    2799 Move_To_Next_BCD_Byte
lcomment 279B All BCD bytes checked?
lcomment 279D No, check the next BCD byte
label    27A0 Copy_Player_To_Hi_Score
lcomment 27A0 3 BCD bytes, 02, 01, 00
label    27A2 Copy_Player_To_Hi_Score_1
lcomment 27A7 Return when all bytes copied
comment  27AA
label    27AA Display_Rocket_Flame
lcomment 27AE Object $0A = Flame (or maybe Rocket?)
label    27B3 Display_Rocket_Flame_1
comment  27B5
comment  27BD
lcomment 27C3 0019 must be height of rocket
comment  27C5
lcomment 27C5 Check rocket height
lcomment 27C7 Display Flame
lcomment 27C9 Don't display Flame
comment  27CB
label    27E1 Display_Rocket_Flame_2
lcomment 2806 ZP0C_Col_RAM_Ptr_Lo
lcomment 2809 ZP0C_Col_RAM_Ptr_Lo
comment  280B
comment  280B Restore 11 and 19 and return
label    280B Display_Rocket_Flame_3
label    2812 No_Display_Flame
label    2819 Display_Flame
comment  282E Using A to toggle, Load A and Y with Ship UDG address
label    282E Get_Flame_UDG_Addr
label    283A Ptr_Rocket_Flame_Lo
lcomment 283A Addr of rocket flame UDG
const    283A-283d
label    283B Ptr_Rocket_Flame_Hi
label    283C Ptr_Final_Char_Lo
lcomment 283C Addr of final char UDG
label    283D Ptr_Final_Char_Hi
comment  283E
label    283E FIRE_PRESSED
lcomment 2841 Remove=Gems all fall through platforms and floor, reentering at top
label    2851 FP_1
comment  2867
comment  2867 Jetman pickup Gem/Elements/Gold etc = 250 points
word     286B
const    286B
break    286D
label    2874 Jump_To_Subroutine_List3
label    2888 Subroutine_List3
word     2888-2891
break    2888-2891
label    2889 Subroutine_List3+1
label    2892 Set_Obj_Posn_05_To_07
label    2894 SR3_Store_To_Obj_Posn_05_06
label    289F Set_Obj_Posn_05_To_06
label    28A4 Set_Obj_Posn_05_To_03_Or_00
label    28B1 Set_Obj_Posn_05_To_03
label    28B6 Set_Obj_Posn_05_To_01_Or_Other
label    28C0 Set_Obj_Posn_05_To_01_Or_Oth_1
label    28C9 Reset_Objects_1_To_8
comment  28CD
comment  28CD
comment  28CD
comment  28CD
comment  28CD
label    28CD Reset_Objects_1_To_8_1
comment  28D4 Init Jetman, Lasers, Rocket and Aliens
label    28D4 Init_Most_Objects
label    28D8 Loop_28D8
comment  28DE
comment  28DE Init all Alien objects
label    28E0 Loop_28E0
label    28E7 Save_Obj_List_Ptr
label    28F0 Restore_Obj_List_Ptr
comment  28F9
label    28F9 Change_Object_To_Explosion_1
comment  28FC
comment  28FC Reset Alien? object direction
comment  2902
comment  2902 Setup Alien? object color flashing/cycling
lcomment 2906 Zero bits 0-5 i.e. xx000000
lcomment 2908 Set bits 0-1 i.e. xxxxxx11
comment  290A
label    290A Store_Object_Type
comment  290E
comment  290E Change object type to an Explosion
comment  2914
comment  2914 Reset diagonal jiggles
comment  2919
comment  2919 Change Alien?/Explosion object colour based on timer
lcomment 291B Zero bits 3-8 i.e. 00000xxx
lcomment 291F Set bit 0 i.e. xxxxxxx1
label    2921 Store_Object_Type_1
lcomment 2925 Color code
label    2927 Store_Object_Type_2
comment  292B
comment  292B Trigger explosion sound (noise + regular oscillator)
label    2934 EXPLOSIONS
label    294A Explosions_1
label    2967 Explosion_UDG_Ptr
word     2967-2974
label    2968 Explosion_UDG_Ptr+1
break    2969
break    296E
label    2975 Explosions_2
label    2987 Game_Over
label    2997 Game_Over_1
label    299D Sound_Channels_Off_ETC
comment  29AB
comment  29B3
comment  29BB
label    29C3 Sound_Channels_Off_ETC_1
label    29C7 Sound_Channels_Off_ETC_2
label    29D0 Sound_Channels_Off_ETC_3
label    29DB Sound_Channels_Off_ETC_4
label    29E7 Display_Game_Over
lcomment 29EA Game Over for P1 or P2?
label    29EE Display_Game_Over_P1
lcomment 29F1 ZP_Ptr_To_Str
lcomment 29F2 Pointer to "GAME OVER PLAYER 1"
word     29F2
lcomment 29F4 ZP_UDG_RAM_X ZP_UDG_RAM_Y
lcomment 29F5 X Y
word     29F5
label    29F8 Display_String_
comment  29FB
lcomment 29FE Into ZP addr 02 and 03...
lcomment 29FF ...load 00 and 00
word     29FF
const    29FF
lcomment 2A01 Into ZP addr 0A and 0B
lcomment 2A02 ...load F8 and 00
word     2A02
const    2A02
comment  2A05
comment  2A05 Delay loop $100^2 x ($100-$f8=$08) x (5+3) = $400,000 = 4,194,304 cycles @ 1.108MHz PAL = 3.785 Seconds
label    2A05 Delay_Loop_Game_Over
lcomment 2A05 5 cycles
lcomment 2A07 3 cycles when taken, 2 when not taken
label    2A12 Display_Game_Over_P2
lcomment 2A15 ZP_Ptr_To_Str
lcomment 2A16 Pointer to "GAME OVER PLAYER 2"
word     2A16
lcomment 2A18 ZP_UDG_RAM_X ZP_UDG_RAM_Y
const    2A18
lcomment 2A19 X Y
word     2A19
label    2A1F STR_GAME_OVER_PLAYER_1
label    2A32 STR_GAME_OVER_PLAYER_2
break    2A32
label    2A45 Object_Pointer_To_Jetman
word     2A4C
comment  2A4F
comment  2A4F Set Jetman Move Speed to 1
comment  2A55
comment  2A55 Object type
comment  2A5F
label    2A5F LEVEL_1_PLUSSES
comment  2A67
comment  2A67 Alien not hit by laser, check to see if hit platform, aliens bounce off after Level 0 so
comment  2A67 update direction
label    2A67 Level_1_Plusses_1
comment  2A6D
label    2A6D LEVEL_2_BALLS
comment  2A75
comment  2A75 Alien not hit by laser, check to see if hit platform, aliens bounce off after level 0
comment  2A75 so update direction
label    2A75 Level_2_Balls_1
comment  2A78
comment  2A78 Read Y direction reversal countdown, branch if zero, else decrement countdown
deflabel 2A79 OBJECT_Y_DIR_COUNTDOWN_PARAM
comment  2A83
comment  2A83
comment  2A83
comment  2A83 Below routine common to Level 1 and 2
label    2A83 Update_Alien_X_Y_Direction
deflabel 2A84 OBJECT_X_DIRECTION_PARAM
label    2A8B Update_Alien_X_Direction
comment  2A8D
comment  2A8D Update_Alien_Y_Direction
deflabel 2A8E OBJECT_Y_DIRECTION_PARAM
label    2A95 Update_Alien_Y_Direction
comment  2A9A
label    2A9A Alien_Direction_Up
label    2A9E Alien_Direction_Left
comment  2AA2
comment  2AA2 Countdown timer at zero, randomly change Y direction using IRQ counter, range $10-$1F
label    2AA2 Update_Y_Direction_Random
binary   2AA5
comment  2AAA
comment  2AAA Invert Y direction up/down, randomly via IRQ
deflabel 2AAB OBJECT_Y_DIRECTION_PARAM
binary   2AAD
comment  2AB2
comment  2AB2 Do the inversion on the direction byte
binary   2AB3
comment  2AB7
label    2AB7 Update_Y_Direction_Random_1
comment  2ABC
label    2ABC LEVEL_3_SAUCER
comment  2AC4
comment  2AC4 Alien not hit by laser, check to see if hit platform, aliens bounce off after level 0 so
comment  2AC4 update direction
label    2AC4 Level_3_Saucer_Update_X
comment  2AC7
comment  2AC7
comment  2AC7 Saucers home-in on Jetman, thus below code is in four sections:
comment  2AC7 - Two sections update X depending on whether alien is left or right of Jetman
comment  2AC7 - Two sections update Y depending on whether alien is above or below Jetman
comment  2AC7 Update Alien Direction X
deflabel 2AC8 OBJECT_X_POSITION_PARAM
comment  2ACB
comment  2ACB Update Y register to index Direction X
comment  2ACC
comment  2ACC Compare alien and jetman positions, jump if alien to left of Jetman
comment  2AD2
comment  2AD2 Load Direction X, jump if alien is moving right
comment  2AD7
comment  2AD7 Test Direction X, when FC reached, Direction resets to $03
comment  2ADB
comment  2ADB Alien and Jetman Position X is now equal, decrement direction
label    2ADB Level_3_Saucer_Dec_Direction_X
comment  2ADD
label    2ADD Level_3_Saucer_Store_Directn_X
comment  2ADF
comment  2ADF
comment  2ADF Update Alien Direction Y, same as Update Direction X, so deliberately fewer comments
label    2ADF Level_3_Saucer_Update_Y
deflabel 2AE0 OBJECT_Y_POSITION_PARAM
comment  2AEA
comment  2AEA Load Direction Y, jump if alien is moving down
label    2AF3 Level_3_Saucer_Dec_Direction_Y
comment  2AF5
label    2AF5 Level_3_Saucer_Store_Directn_Y
comment  2AF7
label    2AF7 Level_3_Saucer_EXIT
comment  2AFA
comment  2AFA Alien is to the left of Jetman
label    2AFA Level_3_Saucer_Alien_Left_X
label    2B03 Level_3_Saucer_Inc_Direction_X
comment  2B08
comment  2B08 Alien is to the below Jetman
label    2B08 Level_3_Saucer_Alien_Below_Y
label    2B11 Level_3_Saucer_Inc_Direction_Y
comment  2B16
comment  2B16 Test if alien has hit a platform, if yes, bounce off with direction change
label    2B16 Test_Platform_Collision_Bounce
lcomment 2B16 Remove=(Not triggered on first level, so don't yet know)
comment  2B1D
comment  2B24
comment  2B2B
label    2B2F Test_Platform_Collision_Bounc_1
label    2B36 Test_Platform_Collision_Bou_RTS
label    2B37 Test_Platform_Collision_Bounc_2
label    2B42 Test_Platform_Collision_Bounc_3
comment  2B4B
comment  2B4B Test if Jetman is onscreen
label    2B4B Spawn_Rocket_Modules_Fuel_Cell
lcomment 2B4E Zero bits 6 & 7
binary   2B4F
label    2B52 RTS_2B52
comment  2B53
comment  2B53 Return if Jetman not only flying or standing or no rocket module/fuel onscreen
label    2B53 Spawn_Rocket_Modules_Fuel_Ce_1
comment  2B5C
comment  2B5C Return if ship is built and fuelled up
comment  2B63
comment  2B63 Use counter to randomly spawn another Fuel Cell
binary   2B66
binary   2B68
comment  2B6B
comment  2B6B Init Rocket Part or Fuel Cell object (8 attributes)
label    2B6D Loop_2B6D
comment  2B76
comment  2B76 Spawn object at a random X position
comment  2B7F
label    2B7F Init_Obj_Rocket_or_Fuel_Table
const    2B82
comment  2B87
label    2B87 Init_Obj_Valuable_Table
const    2B8A
comment  2B8F
comment  2B8F
label    2B8F Spawn_Valuables
lcomment 2B92 Zero bits 6 & 7 i.e. 00xxxxxx
binary   2B92
label    2B96 RTS_2B96
comment  2B97
comment  2B97 Return if Jetman not only flying or standing or valuable onscreen
label    2B97 Spawn_Valuables_1
comment  2BA0
comment  2BA0 Use counter to randomly spawn another valuable
binary   2BA3
comment  2BA6
comment  2BA6 Init Flashing Valuable object (8 attributes)
label    2BA8 Loop_2BA8
comment  2BB1
comment  2BB1 Spawn object at a random X position
comment  2BB7
comment  2BB7 Use counter to setup next object type
binary   2BBA
comment  2BC0
comment  2BC0 Bit 3 wasn't set, so zero all bits apart from bit 3
comment  2BC0 Bit 3 will make the object the diamond which cycles through all colors
binary   2BC1
comment  2BC2
comment  2BC2 Make the valuble type $2x, maybe used as an offset later?
label    2BC2 SKIP_2BC2
binary   2BC3
comment  2BC7
comment  2BC7 03C0 object starts as Rocket Module Middle, then Fuel Cell
label    2BC7 Load_ZP_Params_For_Object_03C0
lcomment 2BCD
const    2BCD
word     2BCE
const    2BCE
comment  2BD4
deflabel 2BD5 OBJECT_VALUABLE_TYPE
comment  2BDE
comment  2BDE Use VIC raster value to create a random X parameter for new object
label    2BDE Get_Random_X
comment  2BE8
comment  2BE8 Table of possible X positions for spawned new object
label    2BE8 Object_X_Table
const    2BE8-2BF7
break    2BE8-2BF7
comment  2BF8
comment  2BF8
comment  2BF8 Store Obj_Laser_0 address in ZP_08/09 ($0388)
comment  2BF8 Replace call with RTS at 2C64 and you can't shoot any aliens
label    2BF8 Test_Laser_Hits_1
comment  2C00
comment  2C00 Store number of lasers (4) for processing to ZP_02
comment  2C04
comment  2C04 Store current object (not the laser) X and Y in ZP_06/07
deflabel 2C05 OBJECT_Y_POSITION_PARAM
lcomment 2C06 Object Y
lcomment 2C0B Object X
comment  2C10
comment  2C10 Test if laser X-coords have bit 2 set, not sure why
label    2C10 BACK_2C10
deflabel 2C11 LASER_X_POSITION_PARAM
lcomment 2C12 X-coord of end of laser
lcomment 2C1A Delayed X-coord of end of laser
comment  2C21
comment  2C21 Test if next object is in use
label    2C21 SKIP_2C21
comment  2C27
comment  2C27 Test Y position???
comment  2C31
lcomment 2C34 Zero bits 0-2
binary   2C35
comment  2C3D
label    2C42 SKIP_2C42
comment  2C46
comment  2C46 Return $80 in ZP_02
comment  2C4A
comment  2C4A Zero bit 2 i.e. xxxxx0xx
comment  2C53 Increment current object address and decrement object counter
label    2C53 Goto_Next_Obj
comment  2C5A
comment  2C5A Decrement object counter, return when all processed
label    2C5F Test_Laser_Hits
comment  2C6A
label    2C6A LEVEL_0_FUZZBALL
comment  2C6F
comment  2C6F Alien not hit by laser, test if alien hit platform, if yes explode,
comment  2C6F else test if alien hit Jetman
comment  2C78
comment  2C78 Alien has been hit by laser, use current player level to create points table offset
label    2C78 Alien_Hit_Update_Score
binary   2C7B
comment  2C7E
comment  2C7E Get score high byte and save
comment  2C84
comment  2C84 Get score low byte and save
comment  2C8C
label    2C8C Change_Object_To_Explosion
comment  2C92
comment  2C92
comment  2C92
comment  2C92
comment  2C92 Test if object has collided with Jetman, if not, update position
label    2C92 Test_Jetman_Collide
comment  2C99
comment  2C99 Alien has hit Jetman
comment  2C9F
comment  2C9F Get object direction/speed and use to create new X value
label    2C9F Update_Object_Position
deflabel 2CA0 OBJECT_X_DIRECTION_PARAM
comment  2CAB
comment  2CAB Take care of X screen wrapping (note $f0=-16 decimal)
deflabel 2CB0 SCREEN_WIDTH_PIXELS
label    2CB3 Update_Object_X_Position
comment  2CB5
comment  2CB5 Get object direction/speed and use to create new Y value
deflabel 2CB6 OBJECT_Y_DIRECTION_PARAM
comment  2CC3
comment  2CCC
label    2CCC Wrap_Object_X_Position_Left
comment  2CD1
label    2CD1 Wrap_Object_X_Position_Right
comment  2CD6
label    2CD6 Obj_Ptr_To_Alien_0_Flsh_Ctr
label    2CDB Alien_Points_Lookup_Table
word     2CDB-2CE2
const    2CDB-2CE2
label    2CE3 Obj_Ptr_To_Alien_0_Jetman
deflabel 2CE9 JETMAN_FLYING
deflabel 2CED JETMAN_STANDING
comment  2CF1 Set Object List Pointer to first alien object
label    2CF1 Set_Obj_List_Ptr_To_Alien_0
comment  2CF9
comment  2CF9 Setup 6 alien objects DEBUG Set 2CFA to 1 to spawn only 1 alien
lcomment 2CFB Counter variable
label    2CFF Next_Object
lcomment 2CFF Get object type
lcomment 2D01 Object not currently used
comment  2D03
comment  2D03 Move pointer to next object
lcomment 2D0A Dec object counter
comment  2D0F Initiate new alien object
comment  2D0F InReg Y always 0
comment  2D0F Set type depending on current level i.e. 0, 1, 2 or 3
label    2D0F Init_Alien_Object
lcomment 2D11 Zero bits 2-7
lcomment 2D13 Save current level
comment  2D19
comment  2D19 Set initial X position to 1
comment  2D1D
comment  2D1D Set initial direction randomly using IRQ counter
comment  2D28
comment  2D28 Set initial Y position randomly using IRQ already in X
comment  2D30
comment  2D30 Set diagonal movement randomly or not
comment  2D35
comment  2D35 Set object colour randomly, store 0 or 1 in ZP_02
comment  2D3B
comment  2D3B Set object colour randomly, lookup table has 2 colours per level
binary   2D3F
comment  2D49
label    2D4C Level_Alien_Type_Lookup
label    2D50 Level_Alien_Color_Lookup
break    2D54
comment  2D58
comment  2D58 ----------------------------------------------------------
comment  2D58 FUNCTION : Tests if Jetman and the current object have
comment  2D58 \           overlapped i.e. collided. Object can be rocket
comment  2D58 \           part, fuel pod, gem or alien.
comment  2D58 ENTRY : ZP_Obj_List_Ptr = Current Object
comment  2D58 \        Obj_Jetman_Looks = Status of Jetman
comment  2D58 EXIT  : ZP_01_Lo = $00 No hit / $80 = Collide
comment  2D58 ----------------------------------------------------------
label    2D58 Test_Jetman_Object_Collide
lcomment 2D61 Jetman flying?
lcomment 2D63 Yes, branch
lcomment 2D65 Jetman standing?
lcomment 2D67 Yes, branch
comment  2D69
label    2D69 Test_Jetman_Obj_Collide_1
lcomment 2D69 If Flashing Score, no collision
comment  2D6E
label    2D6E Test_Jetman_Obj_Collide_2
lcomment 2D6E Default No Collision unless tests work out
lcomment 2D70 Reset variable
comment  2D72
lcomment 2D72 Y=1
lcomment 2D77 Compare objects X-coord vs Jetman's
comment  2D80
label    2D80 Test_Jetman_Obj_Collide_3
lcomment 2D82 Carry Set? Yes, Return
comment  2D84
lcomment 2D84 Y=2
lcomment 2D85 Y=3
lcomment 2D8A Compare objects Y-coord vs Jetman's
comment  2D93
label    2D95 Test_Jetman_Obj_Collide_4
lcomment 2D95 Carry Set? Yes, return
comment  2D97
lcomment 2D97 Set ZP_01_Lo = $80 and return
label    2D9B Test_Jetman_Obj_Collide_RTS
label    2D9C Test_Jetman_Obj_Collide_5
comment  2DA1
label    2DA1 Restore_Player_Objects
label    2DA9 Restore_Player_Objects_1
label    2DB5 Restore_Player_Objects_2
word     2DBC
label    2DC5 Restore_Player_Objects_3
label    2DCB Restore_Player_Objects_4
label    2DD1 Restore_Player_Objects_5
label    2DDD Set_Object_UDG_Color
label    2DE8 Restore_Player_Objects_6
lcomment 2DEC Current level modulus 4
comment  2DF1
comment  2DF9
label    2DFF Dec_Saved_Obj_List_Params_by_10
comment  2E17
comment  2E17 Aliens keep moving also
label    2E17 ROCKET_ASCEND
lcomment 2E1A Object height offset
lcomment 2E1C Load object height i.e. Rocket
lcomment 2E1E Object hit top yet
lcomment 2E20 Yes, branch
lcomment 2E23 Calculate new height
lcomment 2E25 Store new height i.e one pixel up
comment  2E27
comment  2E27 Trigger rocket flight sound
comment  2E31
label    2E34 Rocket_At_Top
comment  2E4E
comment  2E4E Flames stop a little way before bottom
label    2E4E ROCKET_DESCEND
comment  2E51
comment  2E51 Trigger rocket flight sound
comment  2E5B
comment  2E5B Move object Y position down 1 pixel, stopping at bottom i.e. $AF
lcomment 2E5B 03 = Height of object
lcomment 2E64 Hit bottom of playarea
comment  2E68
comment  2E68 Set current object type to a crash
comment  2E74
comment  2E74 This always seems to be a test for Jetman collide with Rocket
label    2E74 ROCKET_BOTTOM_MODULE
lcomment 2E77 Jetman collided with rocket?
lcomment 2E7A Set by collision test
lcomment 2E7C Collision? If no, branch
comment  2E7E
comment  2E7E Collision occured, handle it
lcomment 2E80 Get number of fuel pods delivered into rocket
lcomment 2E82 Rocket fully fueled up?
deflabel 2E83 FUELLED_UP
lcomment 2E84 No, branch
comment  2E86
comment  2E86 Set Rocket object to Ascend
deflabel 2E87 ROCKET_ASCENDING
comment  2E8F
comment  2E8F Don't display Jetman next time? Also zeroes Jetman X coord.
word     2E93
comment  2E96
comment  2E9C
comment  2EAC
label    2EAC Rocket_Fuelled_Up
label    2EB5 Rocket_Fuelled_Up_1
comment  2EC0
label    2ECA Rocket_Fuelled_Up_2
label    2EFD Rocket_Fuelled_Up_3
label    2F01 Rocket_Fuelled_Up_4
label    2F07 Rocket_Fuelled_Up_5
comment  2F0D
comment  2F13
label    2F16 Rocket_Fuelled_Up_6
lcomment 2F1A ZP0C_Col_RAM_Ptr_Lo
lcomment 2F1D ZP0C_Col_RAM_Ptr_Lo
lcomment 2F1F ZP0C_Col_RAM_Ptr_Lo
lcomment 2F24 ZP0C_Col_RAM_Ptr_Lo
lcomment 2F26 ZP0D_Col_RAM_Ptr_Hi
lcomment 2F2A ZP0D_Col_RAM_Ptr_Hi
comment  2F31
comment  2F31 Test if rocket part has landed, $08=middle part, $10=top part
comment  2F31 $18=Fuel (?!)
label    2F31 Rocket_Part_Or_Fuel_Dropped
deflabel 2F32 OBJECT_Y_WHEN_LANDED_PARAM
comment  2F39
comment  2F39 Rocket part dropped, add current Y postion to landed Y position
comment  2F39 and test to see if object has hit the ground
deflabel 2F3B OBJECT_Y_POSITION_PARAM
deflabel 2F40 SCREEN_BOTTOM
comment  2F43
comment  2F43 Rocket part landed, activate next object i.e. set
comment  2F43 status = not dropping and not picked-up by Jetman
comment  2F43 Note, using direct addressing, not using Y offset
lcomment 2F46 Set bit 0
binary   2F47
comment  2F4E
comment  2F4E Multiply rocket direction(???) by $10 and store
comment  2F57
comment  2F57 Subtract ZP13 ($10 when rocket middle landed, $20 for top section landed) from
comment  2F57 Rocket Part Bottom Y position and store in Obj_Y_Position_2
comment  2F65
comment  2F65 Turn Rocket Middle Section object off in list
label    2F65 Disable_Object_In_List
comment  2F6A
comment  2F6A Trigger sound for valuable pickup and rocket part/fuel cell
comment  2F6A landing on rocket base
comment  2F74
label    2F77 Fuel_Dropped
deflabel 2F78 OBJECT_Y_POSITION_PARAM
deflabel 2F7C FUEL_Y_WHEN_LANDED
comment  2F7F
comment  2F7F Fuel cell has landed, increment the counter
comment  2F8E On game startup whilst score flash, no Jetman, no Aliens, alternates between 03B8 and 03C0 i.e. two rocket parts
comment  2F8E On game startup 03B8+04=00, 03C0+4=01
comment  2F8E Pickup  middle section 03B8+04=00, 03C0+4=03
comment  2F8E Falling middle section 03B8+04=00, 03C0+4=07
comment  2F8E Landed  middle section 03B8+04=01, 03C0+4=07
comment  2F8E 03C0 turns into a 0E_Valuable, 03B8 goes round the same cycle as 03C0
comment  2F8E 03B8 becomes a fuel cell
comment  2F8E When middle rocket section deposited, only 03B8 checked, despite dropped valuable
comment  2F8E When top rocket section lifted, still only 03B8 checked, despite dropped valuable
comment  2F8E When top rocket section deposited and fuel dropped, still only 03B8 checked
comment  2F8E When fuel picked-up and dropping onto rocket, still 03B8 checked.
comment  2F8E When fuel drops into rocket, for a short time, no interrupt until next fuel cell drops 03B8
label    2F8E ROCKET_PART_OR_FUEL
comment  2F91
comment  2F91 Test status of the rocket part or fuel cell object
comment  2F91 001=Ready to Pickup, 011=Picked-up, 111=Dropped/Landed
deflabel 2F92 LIFECYCLE_STATE
comment  2FA4
comment  2FA4 Test if Jetman has collided with a rocket part or fuel cell?
comment  2FAB
comment  2FAB Test if rocket part or fuel cell has landed on a platform
comment  2FAB Rocket top part only falls when middle part deposited
comment  2FAB DEBUG NOP the JSR and rocket part or fuel keeps falling
comment  2FB2
comment  2FB2 Move object down by 2 pixels, make Y an odd number
label    2FB2 Rocket_Part_Or_Fuel_Move_Down
deflabel 2FB3 OBJECT_Y_POSITION_PARAM
comment  2FBD
comment  2FBD Load current object attributes into ZP variables and object index into A
label    2FBD Setup_Object_Addr_Rocket_Fuel
comment  2FC3
comment  2FC3 Using index into object data, get addr of object data to A and Y and setup into ZP
label    2FC3 Setup_Object_Addr
comment  2FCB
comment  2FCB Do it again to setup the object dimensions
comment  2FDA
comment  2FDA Returns UDG object data offset to Rocket Middle Section/Fuel depending on which of the four levels
label    2FDA Get_Obj_UDG_Stat_Addr_Ship_Lvl
comment  2FDC
comment  2FDC Calculate and return offset to object's address based on A e.g. player level
comment  2FDC First ship is for levels 0-3, second ship for levels 4-7 then repeat
label    2FDC Get_Obj_UDG_Stat_Addr_Ship_A
binary   2FDE
deflabel 2FE0 OBJECT_PARAM
comment  2FE5 Using A as offset, Load A and Y with Ship UDG address
label    2FE5 Get_Obj_UDG_Static_Addr_S_F_V
comment  2FEE
comment  2FEE At point when Jetman picks up Rocket or Fuel module
label    2FEE Jetman_Collide_Rocket_Fuel
lcomment 2FF1 Diag attrib? Not sure...
lcomment 2FF5 Zero all bits except bit 1 i.e. 000000x0
comment  2FF9
comment  2FF9 Jetman pickup Rocket Module / Fuel Pod = 100 points
word     2FFD
const    2FFD
comment  3003
comment  3003 Trigger collision pickup sound
lcomment 3005 Flame object X pos??
lcomment 300A Flame object direction?
comment  300D
lcomment 3012 Store current Jetman object X pos into current object?
lcomment 3019 Store current Jetman object Y pos into current object?
label    301E Copy_Jetman_XY_To_Object
comment  3028
comment  302F
label    303E Copy_Jetman_XY_To_Object_0
comment  3042
comment  304A
label    3051 Copy_Jetman_XY_To_Object_1
label    3054 Load_Rocket_or_Fuel_UDGs
label    3057 Load_Rocket_or_Fuel_UDGs_1
label    305A Load_Rocket_or_Fuel_UDGs_2
comment  3063
label    3063 Update_Score
lcomment 3065 If P2, setup P2 Score instead of P1 and then return after the param setup below
comment  3067
comment  3067 Read ZP Params P1 Score
lcomment 306A ZP_03_Lo
lcomment 306B P1 Score in ZP
word     306B
comment  306E
label    306E Add_3_Digit_BCD_To_Score
lcomment 306E 3 digits
comment  3070
comment  3070 Add units
lcomment 3070 Set Decimal Mode
comment  3078
comment  3078 Add tens
comment  307F
comment  307F Add hundreds
lcomment 3086 Clear Decimal Mode
comment  3087
lcomment 3087 Decide if working with P1 or P2
label    308e Display_P2_Score_JMP
label    3091 Read_ZP_Params_P2_Score
lcomment 3094 ZP_Temp_2
lcomment 3095 P2 Score in ZP
word     3095
comment  309B
label    309B PCT_0
comment  30A1
lcomment 30A1 Save A
lcomment 30AC Restore A
comment  30AD
comment  30B3
comment  30B3 ----------------------------------------------------------
comment  30B3 Platform Collision Test
comment  30B3 ----------------------------------------------------------
comment  30B3 FUNCTION  : setsoe
comment  30B3 \            snethuoistn
comment  30B3 \            ethonshu.
comment  30B3 CALLED BY :
comment  30B3 CALLS     : Nothing
comment  30B3 ARGUMENTS : ZP_xxxx
comment  30B3 \            satoehsaeuht
comment  30B3 \            sathoeusanteho
comment  30B3 ----------------------------------------------------------
comment  30B3 Triggers with Jetman and 3 objects, then again with Jetman and different 3 objects, then...
label    30B3 Test_Platform_Collision
lcomment 30B5 1st run: Points to 03C0+1 Rocket Middle Section horizontal position = $50 i.e. #10 characters across
lcomment 30B7 1st run: Y=50
lcomment 30BB 1st run: Points to 03C0+3 Rocket Middle Section vertical   position = $5F i.e. on middle platform
lcomment 30BD 1st run: X=5f
lcomment 30BF Set Temp4 to address of data table at 31B6
label    30C2 Test_Platform_Collision_1
lcomment 30C4 Set Temp1Lo=0
lcomment 30C6 31B6: 10 40 03 50 60 01 88 30
lcomment 30C9 1st run: 10-50=C0 i.e. -40
lcomment 30CB 1st run: Branch taken
comment  30CD
lcomment 30CD Save A
lcomment 30D3 Restore A
comment  30D4
label    30D4 Test_Platform_Collision_2
comment  30D8
lcomment 30D8 Save A
lcomment 30DE Restore A
comment  30DF
label    30DF Test_Platform_Collision_3
label    30EC Test_Platform_Collision_4
label    30FD Test_Platform_Collision_5
label    310F Test_Platform_Collision_6
comment  3118 y reg is pointer into lookup table, 3 groups of 3
label    3118 INY_3
lcomment 3118 3 iny's when moving from Y check to Y check
label    3119 INY_2
lcomment 3119 2 iny's when moving from X check to X check as y already inc'd
lcomment 311B Temp5 used as 3-2-1 countdown
label    312D Test_Platform_Collision_7
label    3130 Test_Platform_Collision_8
label    3138 ORA_Temp1Lo_And_StoreTo_Temp1Lo
label    313C Test_Platform_Collision_9
label    313D Test_Platform_Collision10
comment  3143
label    3143 _31B6_To_Tmp4_03_To_Tmp5_Yto00
lcomment 3143 Loads address to data from $31B6 i.e. 10 40 03 50 60 01 88 30 03
label    3152 Draw_Platforms
label    3155 DP_1
lcomment 3155 Get X value from lookup table ($10)
lcomment 3157 \ and store
comment  3159
lcomment 315A Get Y value from lookup table ($40)
lcomment 315C \ and store
comment  315E
lcomment 315F Get ??? value from lookup table ($03)
lcomment 3161 \ and store
comment  3163
comment  316B
comment  316B Load Temp_3 with addr of left end platform UDG char
comment  3173
comment  3173 Copy left end platform UDG char to RAM, bytes 9 per column
comment  3178
comment  3178 Copy middle platform and right end UDG chars to RAM, 9 bytes per column
label    317B Loop_Next_Char
comment  3180
comment  3186
comment  3186 Set the color mapping for the platforms to Green
deflabel 3192 GREEN
label    3193 DP_2
lcomment 3193 ZP0C_Col_RAM_Ptr_Lo
label    31A2 Next_UDG_Char_Loop_Next_Char
label    31A8 Next_UDG_Char
comment  31B6
comment  31B6 Platform data for 3143_Subroutine, 3 platforms: X Y #Num_middle_chars
const    31B6-31BE
break    31B9
break    31BC
comment  31BF
label    31BF A_Left_Right_Impact
deflabel 31C0 JETMAN_X_DIRECTION_PARAM
comment  31C7
comment  31C7 Load and test Jetman X Direction/Velocity
comment  31CB
label    31CB C_Jump_P
comment  31CE
label    31CE B_Fly_Right_Impact
label    31D4 B_Jump_Q
comment  31D7
label    31D7 SKIP_31D7
comment  31DF
comment  31DF BVS/BVC above means below code can only be jumped/branched to
label    31DF E_Fly_Left_Impact
comment  31E7
label    31E7 E_Jump_Q
comment  31EA
label    31EA SKIP_31EA
comment  31F2
comment  31F2
comment  31F2 BVS/BVC above means below code can only be jumped/branched to
comment  31F2 1xxx0001 = Upward impact
comment  31F2 1xxx1000 = Downward impact
comment  31F2 1xxxx1xx = Left or Right impact
comment  31F2 1xxx1110 = Top Right Corner impact
comment  31F2 1xxx0110 = Right impact
comment  31F2 1xxx0111 = Top Left impact
comment  31F2 1xxx0111 = Left impact
label    31F2 H_Jetman_Hits_Surface
comment  31F7
comment  31F7 Test Obj_Jetman_At_Rest???
deflabel 31F8 JETMAN_Y_DIRECTION_PARAM
comment  3200
label    3200 I_Left_Right_Up_Impact
comment  3208
comment  3208 Test Obj_Jetman_At_Rest???
label    3208 J_Flying_Up_Impact
deflabel 3209 JETMAN_Y_DIRECTION_PARAM
binary   3211
comment  3212
label    3212 K_Jump_U
comment  3215
label    3215 J_Jump_T
comment  3218
label    3218 M_Flying_Up_Impact_Bounce
label    3224 SKIP_3224
comment  3228
label    3228 N_Flying_Left
comment  3230
comment  323E
label    323E S_Flying_Right
comment  3246
label    3254 SKIP_3254
comment  3259 HOW DO YOU EVER GET HERE?
label    325E P_INC_A_Jump_Q
label    3264 R__Wrap_Left_To_Right
deflabel 3266 SCREEN_WIDTH_PIXELS
label    326A R__Wrap_Right_To_Left
label    326F P_TXA_Jump_R
label    3273 JETMAN_FLYING_
lcomment 3276 Returns A=%RLDU_F111
lcomment 327B Remove=Jetman+fuel/rocket part pick-up fly through platforms
label    3285 P_Update_Jetman_Position_X
deflabel 3286 JETMAN_X_DIRECTION_PARAM
comment  3291
binary   3295
label    32A2 Q_Store_Jetman_Direction_X
deflabel 32A3 JETMAN_DIRECTION_X_PARAM
label    32A6 R_Update_Jetman_Position_X
deflabel 32A7 JETMAN_POSITION_X_PARAM
comment  32A8
comment  32AB
comment  32AE
deflabel 32B7 SCREEN_WIDTH_PIXELS
label    32BA R__Store_Jetman_Position_X
comment  32BC
label    32C7 T_Update_Jetman_Position_Y
deflabel 32C8 JETMAN_Y_DIRECTION_PARAM
comment  32C9
lcomment 32CB Test for direction Down
lcomment 32CE Yes, branch
lcomment 32D0 Test for direction Up
lcomment 32D3 Yes, branch
comment  32D5
comment  32DE
label    32DE U_Store_Jetman_Direction_Y
comment  32E0
label    32E0 V_Update_Jetman_Position_Y
comment  32E1
comment  32E4
deflabel 32E9 SCREEN_BOTTOM
deflabel 32ED SCREEN_TOP
comment  32F0
comment  32F0 Y becomes index to Direction Y
comment  32F5
comment  32F5 Reverse the direction parameter
comment  32F7
comment  32F7 Gets called with either Jetman Type (index 0) or Jetman_Position_Y (index 3)
label    32F7 W_Store_Jetman_Parameter
comment  32F9
label    32F9 X_Jetman_Screen_Update
comment  32FF
comment  32FF Test for fire pressed
label    3309 SKIP_3309
comment  330C
comment  330C Load and test Jetman Y Direction
label    330C Y_Update_Jetman_Direction_Y
comment  3318
label    3318 T_U_Set_Jetman_Direction_Y_Zro
comment  331D
label    331D V_D_Set_Jetman_Position_Y_Bott
comment  3321
label    3321 D_Set_Jetman_Standing
deflabel 3322 JETMAN_PARAM
comment  3325
comment  3325 ROL saves bit 7 (facing direction), LDA #$04 sets bit 2, ROR restores bit 7 and moves
comment  3325 bit 2 to bit 1 i.e. Jetman action is now Standing
comment  332C
label    332C Set_Obj_List_Ptr_Lo_To_7F
binary   332F
label    3337 Set_Obj_List_Ptr_Lo_To_80
binary   333A
comment  3342
label    3342 Add_B8
label    3348 Add_48
label    334D READ_CONTROLS
label    3367 Flash_Display_Score_JMP
label    336A Read_Controls_1
lcomment 3370 Remove=Jetman+pickup flies/walks jiggle when standing on a platform
label    337D Read_Controls_2
label    338D Read_Controls_3
label    338F Read_Controls_4
label    339D Read_Controls_5
label    339F Jetman_Movement_1
label    33AF Jetman_Movement_2
lcomment 33B3 Test for direction Up
lcomment 33B5 Yes, branch
label    33BA Jetman_Movement_3
label    33C0 Jetman_Movement_4
comment  33D4
comment  33D4 VIA Port A Bit 2=Up, 3=Down, 4=Left, 5=Fire
comment  33D4 VIA Port B Bit 7=Left
comment  33D4 Port A read twice, 1st for Up/Down/Left, 2nd for Fire
comment  33D4 Port B read once for Right
label    33D4 Read_Joystick
lcomment 33D4 %xxFL_DU00, reads $7C=%0111_1100 when nothing pressed
lcomment 33D8 Leaves %FLDU_0000
lcomment 33D9 Set bits 7, 1-4, leaving %1LDU_1111
lcomment 33DB Nothing pressed, byte=$FF at this point
comment  33DD
comment  33DD Read Fire button
lcomment 33DD Same as above
lcomment 33E1 Leaves %xxxx_FLDU
lcomment 33E2 Set bits 0-2 & 5-8, leaving %1111_F111
lcomment 33E4 Merge result into previous reading and store
lcomment 33E6 Leaves %1LDU_F111
comment  33E8
comment  33E8 Read direction Right
lcomment 33EA Set Port B direction all lines read, probably
lcomment 33ED %xxxx_Rxxx, reads $FF=%1111_1111 when nothing pressed
lcomment 33F0 Set bits 0-6, leaving %R111_1111
lcomment 33F2 Merge result into previous reading and store
lcomment 33F4 Leaves %RLDU_F111
label    33F7 Read_Keyboard_Joystick
lcomment 33FA Joystick selected?
lcomment 33FD Yes, branch
comment  33FF
comment  33FF Read Keyboard
comment  340E
lcomment 3414 Set bits 0-5 i.e. xx111111
comment  3418
lcomment 341B Save A
lcomment 341E Set bits 0-2 and 4-7 i.e. 1111x111
comment  3424
lcomment 3424 Restore A
lcomment 3426 Set bits 0-2 and 4-7 i.e. 1111x111
comment  342C
lcomment 3436 Set bits 0-3 and 5-7 i.e. 111x1111
comment  343C
lcomment 3447 Set bits 0-3 and 5-7 i.e. 111x1111
comment  344D
comment  3455
lcomment 3455 Save A
lcomment 3459 Restore A
comment  345A
label    345C Read_Keyboard_1
lcomment 345E Set bits 0-4 and 6-7 i.e. 11x11111
comment  3465
label    3465 Flash_Score
lcomment 3467 P1 or P2? Branch if P2
lcomment 346C Store to ZP_UDG_RAM_X
const    346C
lcomment 346D X Y position in pixels
const    346D
break    346F
label    3470 Flash_Score_1
lcomment 3479 Number of 8-bit wide characters to reverse
label    347B Invert_UDG_Columns
lcomment 347B Number of pixel lines to reverse
label    347D Invert_UDG_Rows
lcomment 347D Get current byte of character
lcomment 347F \ invert it
lcomment 3481 \ and write it back
lcomment 3484 All bytes inverted?
lcomment 3486 \ If yes, continue to next column
lcomment 3487 All columns inverted? If yes, finish
comment  3489
comment  3489 Move to next column by adding $B0 (#176) pixel to X postion
lcomment 348C $B0 = height of screen in pixels i.e. move one column right
comment  3490
comment  3490 Move to top row by adding $B0 (#176) pixeln to X postion i.e. one column
lcomment 3492 Add the carry from the previous $B0 addition for X
label    3499 Flash_Score_RTS
label    349A Load_UDG_RAM_for_P2
lcomment 349D Store to ZP_UDG_RAM_X
lcomment 349E X Y position in pixels
const    349E
break    34A0
comment  34A4
comment  34A4 ----------------------------------------------------------
comment  34A4 Display_BCD_Bytes
comment  34A4 ----------------------------------------------------------
comment  34A4 FUNCTION  : Display
comment  34A4 \            Scores
comment  34A4 CALLED BY :
comment  34A4 CALLS     :
comment  34A4 ARGUMENTS : ZP_UDG_RAM_X ZP_UDG_RAM_Y = UDG array absolute position to display score at
comment  34A4 \            ZP_Ptr_To_Str             = Players score in ZP as BCD e.g. 12 34 56
comment  34A4 \            ZP_Temp_1                 = BCD byte counter i.e. number of bytes to display
comment  34A4 ----------------------------------------------------------
label    34A4 Display_BCD_Bytes
lcomment 34A4 Pointer to raw 12 34 56 in ZP
lcomment 34A6 Load first score byte i.e. 12
lcomment 34A8 Divide by $10
lcomment 34AB 12 has become 01
lcomment 34AD Add $70, $40 gets subtracted later on
lcomment 34AF and resultant $31st char in Char ROM is "1"
comment  34B4
comment  34B4 Display 2nd score character
lcomment 34B6 Load first score byte again i.e. 12
lcomment 34B8 Mask top 4 bits, 12 becomes 02
comment  34C1
comment  34C1 Increment pointer to next score byte
lcomment 34C5 Looks like a bug, should be incrementing ZP_Ptr_To_Str_Hi
label    34C7 Display_BCD_Bytes_0
lcomment 34C7 Decrement number of bytes to display counter
lcomment 34C9 If <> 0 yet, process another byte
comment  34CC
comment  34CC ----------------------------------------------------------
comment  34CC NOT SURE WHAT THIS IS YET
comment  34CC ----------------------------------------------------------
comment  34CC FUNCTION  :
comment  34CC CALLED BY :
comment  34CC CALLS     :
comment  34CC ARGUMENTS :
comment  34CC ZP_PTR_TO_STR  = "COPYRIGHT`qyxs`An" or "JETPAC`GAME`SELEC"
comment  34CC ZP_ColorRAMPtr = "SP START GAME" or "JETPAC`GAME`SELEC"
comment  34CC ZP_UDG_RAM_X   = 08 A8 or 08 20
comment  34CC ZP_UDG_RAM_Y   = 08 A8 or 08 20
comment  34CC ZP_Addr_From   = 70 80 or 28 80
comment  34CC ----------------------------------------------------------
label    34CC Display_String
label    34D2
lcomment 34D2 Y=string character pointer
lcomment 34D4 Get character to display
label    34D6 DSTR1
lcomment 34D6 Stash character to X
lcomment 34D7 Inc character pointer
lcomment 34DA Test if character top bit is set = string end
lcomment 34DB Display character then exit
lcomment 34DD Display character
comment  34E3
label    34E3 Display_Character
comment  34E9
comment  34F0
lcomment 34F3 ZP0C_Col_RAM_Ptr_Lo
comment  34F7
label    34F7 Setup_Color_RAM_Ptr
lcomment 34F7 Get Addr_To lo-byte and divide by 8
lcomment 34F9 and store to Color RAM Ptr lo-byte.
lcomment 34FA ZP_Addr_To is used to work out the column
lcomment 34FC ZP0C_Col_RAM_Ptr_Lo
comment  34FE
lcomment 34FE Get Addr_To hi-byte, divide by $10
lcomment 3500 and use as index into Color RAM
lcomment 3501 Row Offsets i.e. 9600, 9617, 962e etc.
lcomment 3502 Divided by #16 because 16 y-pixels per
lcomment 3503 Color RAM tile.
lcomment 3509 ZP0C_Col_RAM_Ptr_Lo
lcomment 350B ZP0C_Col_RAM_Ptr_Lo
comment  350D
lcomment 350D Store hi-byte of Color RAM
lcomment 350F to pointer hi-byte.
lcomment 350F ZP0D_Col_RAM_Ptr_Hi
label    3512 Color_RAM_Row_Offsets
const    3512-351C
comment  351D
label    351D Convert_XY_to_UDG_RAM_Addr
lcomment 351D Addr_To = 18 68, as example i.e. X=$18 pixels from left, Y=$68 pixels from top
lcomment 351F Addr_To = 18 xx, 68 stashed to Y
comment  3520
lcomment 3520 Get Addr_To lo-byte, divide by 8, example = $18/8=3
lcomment 3526 Load Column offset (4th item = $21)
lcomment 3529 Store back to Addr_To lo-byte, Addr_To = 21 xx
lcomment 352B Reset Addr_To hi-byte to 00
lcomment 352D Addr_To = 21 xx
comment  352F
lcomment 352F Rotate left Addr_To by 4 bits
label    3531 Convert_XY_to_UDG_RAM_Addr_1
lcomment 3536 Addr_To = 1x x2
comment  3538
lcomment 3538 Get stashed Y = 68 to A
lcomment 353C Addr_To = 78 x2
lcomment 3542 Addr_To = 78 12 = "F7 JOYSTICK" start position
label    3545 UDG_RAM_Column_Offsets
lcomment 3545 Bytes are middle two numbers in addr e.g. 10b0, 1160 etc
const    3545-3557
comment  355C
comment  355C ----------------------------------------------------------
comment  355C Reset RAM by filling with a data byte
comment  355C ----------------------------------------------------------
comment  355C ARGUMENTS : ZP_01 = number of bytes to fill
comment  355C \            ZP_02 = start address to fill from
comment  355C \            ZP_04 = Data byte to fill with
comment  355C ----------------------------------------------------------
label    355C Reset_Color_RAM
const    355F
lcomment 3560 Number of bytes to fill
word     3560
const    3562
lcomment 3563 Start address of bytes to fill
word     3563
const    3565
lcomment 3566 Data to fill with (i.e. $01)
word     3566
const    3566
break    3566
break    3568
comment  356C
label    356C Reset_UDG_RAM
const    356F
lcomment 3570 Number of bytes to fill
word     3570
const    3570
const    3572
lcomment 3573 Start address of bytes to fill
word     3573
const    3575
lcomment 3576 Data to fill with (i.e. $00)
const    3576
break    3576
break    3578
comment  3579
label    3579 Reset_RAM
label    357B Reset_RAM_1
label    3584 Reset_RAM_2
comment  3595
comment  3595 ----------------------------------------------------------
comment  3595 Copy Character ROM Character to User-Defined Graphics Memory
comment  3595 ----------------------------------------------------------
comment  3595 FUNCTION  : Copy an 8 byte Character ROM character to the
comment  3595 \            Used-Defined Graphics RAM e.g. to display a
comment  3595 \            text string or score.
comment  3595 CALLED BY :
comment  3595 CALLS     : Nothing
comment  3595 ARGUMENTS : ??? = Loaded with character to copy e.g. $71 for "1"
comment  3595 \            ??? BROKEN COMMENTS Addr_To is already setup, e.g. $1268 in UDG memory "F5 Keyboard".
comment  3595 \            ??? BROKEN COMMENTS Addr_To gets updated as part of this routine.
comment  3595 ----------------------------------------------------------
label    3595 Copy_Char_To_UDG_RAM
lcomment 3595 Addr_From = 71 xx as example
lcomment 3597 Clear address hi-byte
lcomment 3599 Addr_From = 71 00
lcomment 359E Addr_From = 31 00, $31st Character ROM character is "1"
comment  35A0
comment  35A0 Multiply Addr_From by 8, as 8 bytes per UDG RAM character definition
label    35A2 Copy_Char_To_UDG_RAM_1
lcomment 35A5 Addr_From = 31 00 > 62 00 > c4 00 > 88 01 i.e. $0188
lcomment 35A7 Left-shifted 3 times? i.e. multiplied by 8
lcomment 35A8 If no, loop back
comment  35AA
comment  35AA Add $8000 Character ROM offset to address
lcomment 35AE Addr_From = 88 81 i.e. $8188 is Character ROM character "1"
comment  35B0
comment  35B0 Copy 8 bytes to form a complete character
lcomment 35B2 Test the Invert flag
lcomment 35B4 If yes, copy bytes with inversion instead
label    35B6 Copy_Char_To_UDG_RAM_2
lcomment 35B6 Copy bytes from given address with Y offset
lcomment 35B8 Copy bytes to given address with Y offset
lcomment 35BA Decrement number of lines counter
lcomment 35BB All lines copied? If no, loop back.
comment  35BD
comment  35BD Move the next character address to the next column
label    35BD Copy_Char_To_UDG_RAM_NEXT
lcomment 35C0 #B0=176=number of vertical pixels i.e. move to next char right
lcomment 35C6 Increment address hi-byte if previous addition overflowed
comment  35CB
comment  35CB Copy 8 inverted bytes to form a complete character
label    35CB Copy_Char_To_UDG_RAM_INV
lcomment 35CB Copy bytes from given address with Y offset
lcomment 35CD Invert the byte (used to make the byte flash)
lcomment 35CF Move bytes to given address with Y offset
lcomment 35D1 Decrement number of lines counter
lcomment 35D2 All lines copied? If no, loop back.
lcomment 35D4 If yes, routine ends
comment  35D7
label    35D7 Load_Object_Type_X_Y
deflabel 35D8 OBJECT_TYPE_PARAM
comment  35DD
comment  35E2
deflabel 35E3 OBJECT_Y_POSITION_PARAM
label    35E9 Load_Object_Type_X_Y_Color
deflabel 35EA OBJECT_TYPE_PARAM
comment  35EF
comment  35F4
deflabel 35F5 OBJECT_Y_POSITION_PARAM
comment  35FA
deflabel 35FB OBJECT_COLOR_PARAM
comment  3601
label    3601 Display_Object_With_Setup_AB
comment  3604
label    3604 Display_Object_With_Setup_B
comment  360D
label    360D Display_Object_With_Setup_CD
comment  3610
label    3610 Display_Object_With_Setup_D
comment  3619
comment  3619 When object is moving down the screen, the number of pixels it has moved down by will result
comment  3619 in a number of pixel lines at the top of the object that need to be EXOR'd to erase them
comment  3619 Initial EOR/CLC/ADC performs an ABS on old/new object Y position delta for use as loop index
label    3619 Erase_Object_Moving_Downward
comment  361E Note code from 361E & 3663 is basically the same until Erase_Draw, but
comment  361E using old and new object parameters
comment  3622
comment  3622 Set X to number of Y pixel-lines to erase only i.e. don't draw over the erase for this object
comment  3623
comment  3623 Subtract number of Y erase-only pixels from total object tile height and store to loop
comment  3623 index for later
comment  3626
comment  362D
comment  362D Erase old object data bytes from UDG static data to screen RAM by EXORing
comment  362D ZP09 offset decrements from $FF, ZP0E holds address of old UDG object data,
comment  362D ZP0C holds address of object data on screen to be written to
label    362F LOOP_362F
comment  3635
comment  3635 Decrement pointer into UDG static data and the loop index
comment  3639
comment  3639 Restore the number of pixel lines to erased and store to ZP13, then subtract it from
comment  3639 ZP09, the updated address offset for erase/draw the first/next part of the new object
comment  363C
comment  3643
comment  3646
label    3646 Display_Object_With_Setup
comment  364C
label    364C Display_Object
comment  364E ZP08 and ZP09 used as index into UDG RAM for old object and new object data
comment  3652
comment  3652 ZP03 contains the height of a object tile, from the UDG graphics static data
comment  3652 e.g. Alien cross object height is $0A pixels/lines
comment  3652 Rocket is made of 3x2 tiles, fuel cell 1x2, Jetman 1x2 or 1x3
comment  3656
comment  3656 ZP0B contains what...needs more analysis, but appears to hold the same as ZP03
comment  365A
comment  365A Test if updated object Y position has changed, if yes, horizontal pixels can be erased
comment  365A from top or bottom of old object that are outside new object position, else jump
comment  365A directly to erase/draw routine
comment  3663
comment  3663 Erase_Object_Moving_Upward, see also comments for Erase_Object_Moving_Downward
comment  3663 Note code from 361E & 3663 is basically the same until Erase_Draw, but
comment  3663 using old and new object parameters
comment  3667
comment  3667 Set X as number of Y pixel-lines to erase only i.e. no following draw for this object
comment  3668
comment  3668 Subtract number of Y erase-only pixels from total object tile height and store to loop
comment  3668 index for later
comment  366B
comment  3672
comment  3672 Erase old object data bytes from UDG static data to screen RAM by EXORing
comment  3672 ZP08 offset decrements from $FF, ZP06 holds address of old UDG object data,
comment  3672 ZP04 holds address of object data on screen to be written to
label    3674 LOOP_3674
comment  367A
comment  367A Decrement pointer into UDG static data and the loop index
comment  367E
comment  367E Restore the number of pixel lines to erased and store to ZP13, then subtract it from
comment  367E ZP08, the updated address offset for erase/draw the first/next part of the new object
comment  367F
comment  3681
comment  3688
comment  3688 Erasure of old object and drawing of new object is done in the same code loop,
comment  3688 first you erase the old line from screen memory using EXOR, then you write back
comment  3688 to the same line with the new object data
comment  3688 First test to see if old object fully erased, if yes jump to draw updated params
label    3688 Erase_Old_Object
comment  368E
comment  368E EXOR object data bytes from UDG static data to screen RAM to erase
comment  3696
comment  3698
comment  3698 If new object fully drawn, don't try drawing more, erase next old object line
comment  369C
label    369C Draw_New_Object
comment  369E
comment  369E EXOR object data bytes from UDG static data to screen RAM to draw
comment  36A6
comment  36AB
comment  36AB Test if more lines to be drawn for new object, if yes, branch
label    36AB Next_Object_Old_Update_Params
comment  36AF
comment  36AF Test if old object fully erased, if not, move to the next vertical column to erase
comment  36B3
comment  36B5
comment  36B5 Move UDG static data 16-bit address pointer to the object data for the next column
comment  36BC
comment  36C2
comment  36C2 Move UDG RAM pointer to next vertical column
deflabel 36C6 SCREEN_HEIGHT_PIXELS
comment  36C9
comment  36CF
comment  36CF Test for full-screen wrap, $1ED1 is $FF less than the first byte past UDG RAM (last byte = $1FCF)
comment  36DA
comment  36DA Handle full-screen wrap, $0FD0 is number of bytes used to define the full UDG RAM. i.e. $16 x $17 x 8=$FD0
comment  36E1
comment  36E7
comment  36E7 Test if new object fully drawn, if not, move to the next vertical column to draw
label    36E7 Next_Object_New_Update_Params
comment  36EB
comment  36ED
comment  36ED Move UDG static data 16-bit address pointer to the object data for the next column
comment  36F4
comment  36FA
comment  36FA Move UDG RAM pointer to next vertical column
comment  3701
comment  3707
comment  3707 Test for full-screen wrap, $1ED1 is $FF less than the first byte past UDG RAM (last byte = $1FCF)
comment  3712
comment  3712 Handle full-screen wrap, $0FD0 is number of bytes used to define the full UDG RAM. i.e. $16 x $17 x 8=$FD0
comment  3719
comment  371F
label    371F JMP_Display_Object
comment  3722
label    3722 JMP_Display_Object_Zero_ZP0B
comment  3729
label    3729 Object_Width_Complete
comment  372D
comment  372D Test if both old and new object heights are the same, if yes, return
comment  3734
label    3734 JMP_Next_Obj_New_Update_Params
comment  3737
label    3737 Load_Small_UDG_Addr_Setup_XY_
comment  373D
comment  373D Load Small UDG address from A & Y
label    373D Load_Small_UDG_Addr_Setup_XY
comment  3743
comment  3743 Load UDG RAM XY coordinates
comment  374B
comment  374B Load and store UDG addr, including X co-ord wrap
lcomment 3752 $B8=screen width in pixels
deflabel 3753 SCREEN_WIDTH_PIXELS
lcomment 3757 Wrap
deflabel 3758 SCREEN_WIDTH_PIXELS
label    3759 Load_Small_UDG_Addr_Setup_XY_1
comment  375D
lcomment 3765 ZP0C_Col_RAM_Ptr_Lo
comment  3767
lcomment 376B ZP0D_Col_RAM_Ptr_Hi
comment  376D
comment  3775
comment  377C
comment  3783
comment  378A
label    378A Set_UDG_RAM_Ptr_Object_Dimen_
lcomment 378A Returns UDG Addr Lo in Y, Hi in A
comment  378D
comment  378D Store UDG Addr -$100 in ZP 06 & 07, which is added later via Y
label    378D Set_UDG_RAM_Ptr_Object_Dimen
comment  3793
comment  3793 Setup UDG RAM X & Y
comment  379B
comment  379B Convert XY pixel coords to address, managing X axis wrap ($B8)
deflabel 37A3 SCREEN_WIDTH_PIXELS
deflabel 37A8 SCREEN_WIDTH_PIXELS
label    37A9 No_X_Wrap
comment  37AE
comment  37AE Subtract $FF from 16-bit UDG_RAM addr?
comment  37BB
comment  37BB Get/store object width in characters (zero-based)
comment  37C1
comment  37C1 Get/store object height in pixels
comment  37C6
comment  37C6 Subtract $03 from 16-bit object UDG addr, i.e. so address
comment  37C6 avoids the object dimension bytes
comment  37CD
comment  37D4
comment  37D4 Aliens Types: 05=Fuzzball, 06=Saucer, 07=Ball, 08=Cross
comment  37D4 All Aliens have only 2 animation states
comment  37D4 InReg: A=Object Type (Alien), X=Animation Frame
comment  37D4 OutReg: A=UDG Addr Hi, Y=UDG Addr Lo
label    37D4 Get_Obj_UDG_Static_Addr_Alien
comment  37D6
comment  37D6 Convert the object's screen X position to an 0 or 2 animation frame data offset & put back into X
lcomment 37D7 Zero bits 0 & 2-7
binary   37D8
comment  37DB
comment  37DB Transform Object Types 5/6/7/8 to 2/3/4/5, then multiply by 4 to get the frame data offset offset
comment  37DB Note, starting with offset 2 instead of 0 means 4 wasted bytes in the static data address table
comment  37E0
comment  37E0 Add $20 offset, which takes us to the start of the Alien UDG static data, past Jetman static data
comment  37E6 OTHER ENTRY POINT
label    37E6 Get_Obj_UDG_Addr_
lcomment 37E8 Zero bits
bin      37E9
comment  37ED
comment  37ED When object is Jetman, Object Type represents State i.e. Flying/Standing, Facing Left/Right, Frame.
comment  37ED There are 16 Jetman animation frames, 4 Fly Right, 4 Fly Left, 4 Stand Left, 4 Stand Right,
comment  37ED in that order, in a list of 16-bit address to the UDG static data.
comment  37ED This routine uses bit 7 of the Jetman Object Type to select Right or Left and bit 0 to
comment  37ED select Flying or Standing, when creating an offset in register X.
comment  37ED InReg: A=Object Type (Jetman), X=Animation Frame
comment  37ED OutReg: A=UDG Addr Hi, Y=UDG Addr Lo
label    37ED Get_Obj_UDG_Jetman_or_Alien
comment  37EE
comment  37EE Jetman uses only bit 7 (direction he's facing) and bits 0 & 1 (standing/flying).
comment  37EE If other bits are used, object must be an Alien.
lcomment 37EE Zero bits 6 & 7
binary   37EF
lcomment 37f0 Test bits 0 & 1
binary   37F1
lcomment 37F2 Carry Set if A >= compared value
comment  37F5
comment  37F5 Object is Jetman, test state, is he looking Left or Right?
comment  37FA
comment  37FA Jetman is looking left, set bit 3 in X, which adds $08 to the UDG static data address, meaning
comment  37FA that it will point to the Jetman facing Left UDG static data addresses instead of facing Right.
lcomment 37FC Set bit 3
binary   37Fd
comment  3800
comment  3800 A contains Jetman State, bit 7 is Direction-faced. SEC & SBC prepare ASLs to move bit 7 to bit 3
comment  3800 This effectively adds $10 to the calculated UDG static data address when Jetman is Standing,
comment  3800 meaning it points to the Jetman Standing static data addresses instead of Jetman Flying.
label    3800 Get_Obj_UDG_Calc_Jetman
comment  3807
comment  3807 OR A and X together to produce full UDG static data table offset
label    3807 Get_Obj_UDG_Calc_Jetman_Alien
comment  380D
comment  380D Using X just set, get index into the Object UDG table
lcomment 380D Address lo byte into Y
lcomment 3811 Address hi byte into A
comment  3815
comment  3815 Get address of UDG Static Data for Jetman or Alien objects and return in A and Y registers
comment  3815 Bits 1 & 2 of object's X position used to select UDG animation frame.
comment  3815 Animations have 2 or 4 frames and are minimum 2 pixels apart so bit 0 not used.
label    3815 Get_Obj_UDG_Stat_Addr_JM_Alien
lcomment 3817 Reset bits 0 & 3-7
binary   3818
comment  381F
comment  381F
label    381F Update_Color_RAM
comment  3827
comment  3827 Setup Color RAM Pointer using UDG RAM X and Y
comment  382A
comment  382A Divide ZP_17 by $10, height of a color tile?
comment  3835
comment  3835 Outer loop decrementing ZP_0B
comment  3835 Inner loop decrementing ZP_0A
label    383B Update_Color_RAM_1
comment  383F
label    383F Update_Color_RAM_2
lcomment 383F ZP0C_Col_RAM_Ptr_Lo
comment  3847
lcomment 3849 ZP0C_Col_RAM_Ptr_Lo
comment  384B
label    384B Update_Color_RAM_3
comment  384F
lcomment 384F ZP0C_Col_RAM_Ptr_Lo
lcomment 3858 ZP0C_Col_RAM_Ptr_Lo
comment  385A
label    385E Update_Color_RAM_RTS
;
; End of file contains graphics data
;
;unused   3861-3fff ; TEMP STOP THE OUTPUT OF THE GRAPHICS
comment  385F
lcomment 3865 $3C87 = Jetman_Fly_Right_3
label    385F UDG_Lookup_Jetman_Aliens
label    3860 UDG_Lookup_Jetman_Aliens+1
break    385F-3FFF ; Output one byte per line
word     385F-3896
;
; Objects and UDG start here
;
comment  3897
binary   3897-3C86
byte     3C87-3C88
const    3C87-3C88
word     3C89-3CB0
binary   3CB1-3FFF
;
label    38CA Jetman_Fly_Left_0
label    38FD Jetman_Walk_Left_0
label    3930 Jetman_Walk_Left_1
label    397B Jetman_Walk_Left_2
label    39C6 Jetman_Walk_Left_3
label    39F9 Jetman_Walk_Right_0
label    3A2C Jetman_Walk_Right_1
label    3A77 Jetman_Walk_Right_2
label    3AC2 Jetman_Walk_Right_3
label    3AF5 Jetman_Fly_Left_1
label    3B40 Jetman_Fly_Left_2
label    3B8B Jetman_Fly_Left_3
label    3BBE Jetman_Fly_Right_0
label    3BF1 Jetman_Fly_Right_1
label    3C3C Jetman_Fly_Right_2
comment  3C87 $3C87 = Jetman_Fly_Right_3, it's referenced after the end of the object's static data
comment  3C87
label    3C87 UDG_Lookup_Ship_Fuel_Vals
label    3C88 UDG_Lookup_Ship_Fuel_Vals+1
lcomment 3C9F Multiple entries for UDG objects indexing based on player level
label    3E46 Alien_Ship_1
label    3E61 Alien_Ship_2
label    3E78 Alien_Fuzz_1
label    3E99 Alien_Fuzz_2
label    3EB8 Alien_Bubble_1
label    3EEB Alien_Bubble_2
label    3F0E Alien_Cross_1
label    3F41 Alien_Cross_2
label    3CD4 Ship_1_Bott
label    3CF7 Ship_1_Mid
label    3D1A Ship_1_Top
label    3D3D Ship_2_Bott
label    3D60 Ship_2_Mid
label    3D83 Ship_2_Top
label    3D9C Fuel
label    3DAF Gold_Bar
label    3DCA Diamond
label    3DE3 Plutonium
label    3E00 Isotope
label    3E15 Mineral
label    3F74 Explosion_1
label    3F9B Explosion_2
label    3FB2 Explosion_3
; End of File