include nfo_options.nfo           * dasmfw options
include nfo_memory_map.nfo        * Include VIC-20 memory map info
include nfo_separators.nfo        * Include JMP/JSR separator lines
include nfo_code_data.nfo         * Everything is data, unless it's not
include nfo_variables.nfo         * Zero Page and others with persistency

insert ; ----------------------------------------------------------
insert ;  This is the reverse-engineered source code for the
insert ;  game 'JETPAC' written by Ultimate Play The Game.
insert ; ----------------------------------------------------------
insert
insert ; ----------------------------------------------------------
insert ;  Usage of Labels
insert ;  ZP_Obj_List_Ptr_Lo      equ     $0000 - 182
insert ;  ZP_Obj_List_Ptr_Hi      equ     $0001 -  11
insert ;  ZP_01_Lo                equ     $0002 -  46
insert ;  ZP_01_Hi                equ     $0003 -  17
insert ;  ZP_UDG_RAM_X            equ     $0004 -  56
insert ;  ZP_UDG_RAM_Y            equ     $0005 -  35
insert ;  ZP_03_Lo                equ     $0006 -  51
insert ;  ZP_03_Hi                equ     $0007 -  26
insert ;  ZP_04_Lo                equ     $0008 -  42
insert ;  ZP_04_Hi                equ     $0009 -  11
insert ;  ZP_05_Lo                equ     $000A -  15
insert ;  ZP_05_Hi                equ     $000B -  18
insert ;  ZP_Col_RAM_Ptr_Lo       equ     $000C -  28
insert ;  ZP_Col_RAM_Ptr_Hi       equ     $000D -  10
insert ;  ZP_Ptr_To_Str_Lo        equ     $000E -  21
insert ;  ZP_Ptr_To_Str_Hi        equ     $000F -  12
insert ;  ZP_08_Lo                equ     $0010 -  04
insert ;  ZP_08_Hi                equ     $0011 -  09
insert ;  ZP_09_Lo                equ     $0012 -  03
insert ;  ZP_Keyboard_Data        equ     $0013 -  18
insert ;  ZP_0A_Lo                equ     $0014 -  08
insert ;  ZP_0A_Hi                equ     $0015 -  08
insert ;  ZP_0B_Lo                equ     $0016 -  05
insert ;  ZP_0B_Hi                equ     $0017 -  04
insert ;  ZP_0C_Lo                equ     $0018 -  07
insert ;  ZP_0C_Hi                equ     $0019 -  12
insert ;  ZP_0D_Lo                equ     $001A -  03
insert ;  ZP_0D_Hi                equ     $001B -  10
insert ;
insert ; ----------------------------------------------------------

; Start of disassembly instructions
word     2000-2003
break    2004-2013
comment  2004
comment  2004 Initial value table for VIC setup 16 bytes
const    2004-201B
label    2004 VIC_Init_Tab
lcomment 2004 VIC_R0_H_Ctr     Left edge of TV picture and interlace switch.
lcomment 2005 VIC_R1_V_Ctr
lcomment 2006 VIC_R2_Num_Cols
lcomment 2007 VIC_R3_Num_Rows
lcomment 2008 VIC_R4_TV_Raster
lcomment 2009 VIC_R5_CM_Start
lcomment 200A VIC_R6_H_LightP
lcomment 200B VIC_R7_V_LightP
lcomment 200C VIC_R8_Paddle_X
lcomment 200D VIC_R9_Paddle_Y
lcomment 200E VIC_RA_Frq_Osc1
lcomment 200F VIC_RB_Frq_Osc2
lcomment 2010 VIC_RC_Frq_Osc3
lcomment 2011 VIC_RD_Frq_Noise
lcomment 2012 VIC_RE_Vol_Color
lcomment 2013 VIC_RF_BckBdrCol
comment  2014
comment  2014 Quick lookup for BIT instruction
label    2014 MASK_01
label    2015 MASK_02
label    2016 MASK_04
label    2017 MASK_08
label    2018 MASK_10
label    2019 MASK_20
label    201A MASK_40
label    201B MASK_80
comment  201C
comment  201C +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     201C NMI_Interrupt_Hardler
comment  201D
comment  201D ----------------------------------------------------------
comment  201D Starts here
comment  201D ----------------------------------------------------------
lcomment 201D Disable Interrupts
lcomment 201E Reset stack pointer
lcomment 2021 Clear Decimal flag
comment  2022
comment  2022 Setup NMI interrupt vector to service routine at $201C
comment  202C
comment  2032
comment  2032 Setup I/O data direction and interrupt enables
comment  2041
comment  2044
comment  2044 Set VIA outputs for keyboard scan
lcomment 2046 Data I/O register (User port & RS-232) i.e. not used
lcomment 2049 Data I/O register (Keybd col scan, Cassette, Joy)
comment  204C
comment  204C Setup IRQ interrupt vector to service routine at $25E0
comment  2056
comment  2056 Reset the VIC registers
lcomment 2056 16 registers
label    2058 Reset_VIC
comment  2061
comment  2061 Initialize Screen RAM i.e. map screen tiles to User-Defined Graphics RAM
comment  2061 Each character is a 16x8 tile i.e. double height, thus play area
comment  2061 is decimal 11 Rows x 23 Columns
comment  2061 0200  00 0B 16 21 2C 37 42 4D 58 63 6E 79 84 8F 9A A5 B0 BB C6 D1 DC E7 F2
comment  2061 0217  01 0C 17 22 2D 38 43 4E 59 64 6F 7A 85 90 9B A6 B1 BC C7 D2 DD E8 F3
comment  2061 022E  02 0D 18 23 2E 39 44 4F 5A 65 70 7B 86 91 9C A7 B2 BD C8 D3 DE E9 F4
comment  2061 0245  03 0E 19 24 2F 3A 45 50 5B 66 71 7C 87 92 9D A8 B3 BE C9 D4 DF EA F5
comment  2061 025C  04 0F 1A 25 30 3B 46 51 5C 67 72 7D 88 93 9E A9 B4 BF CA D5 E0 EB F6
comment  2061 0273  05 10 1B 26 31 3C 47 52 5D 68 73 7E 89 94 9F AA B5 C0 CB D6 E1 EC F7
comment  2061 028A  06 11 1C 27 32 3D 48 53 5E 69 74 7F 8A 95 A0 AB B6 C1 CC D7 E2 ED F8
comment  2061 02A1  07 12 1D 28 33 3E 49 54 5F 6A 75 80 8B 96 A1 AC B7 C2 CD D8 E3 EE F9
comment  2061 02B8  08 13 1E 29 34 3F 4A 55 60 6B 76 81 8C 97 A2 AD B8 C3 CE D9 E4 EF FA
comment  2061 02CF  09 14 1F 2A 35 40 4B 56 61 6C 77 82 8D 98 A3 AE B9 C4 CF DA E5 F0 FB
comment  2061 02E6  0A 15 20 2B 36 41 4C 57 62 6D 78 83 8E 99 A4 AF BA C5 D0 DB E6 F1 FC
label    2064 ISR_Cols
deflabel 2065 COLUMNS
label    2067 ISR_Rows
deflabel 206C ROWS
deflabel 2076 ROWS
comment  2079
label    2079 Reset_Game_Select
comment  207C
comment  207C Reset game selection flashing highlights
label    2080 RGS_Flash
comment  2085
comment  2085 Setup volume and color
comment  208A
comment  208A Initialise Flame object
comment  208F
comment  208F ----------------------------------------------------------
comment  208F Game Select Loop
comment  208F ----------------------------------------------------------
label    208F Game_Select
;        2093
lcomment 2093 Set Port B all bits to input
lcomment 2098 Set Port A all bits to output
comment  209B
lcomment 209B Select keyboard column to read
lcomment 209D \ (F7/F5/F3/F1/CDown/CRight/Rtn/Del)
lcomment 20A0 Whilst giving keyboard data time to settle?
lcomment 20A3 Read keyboard column
lcomment 20A6 Store keyboard data
lcomment 20AA F1 pressed? (1 Player)
comment  20A8
comment  20A8 Test F-Keys pressed or Space to start game
lcomment 20AC No, skip
lcomment 20AF Reset Bit0 = 1 Player
comment  20B2
label    20B2 Test_F3
lcomment 20B4 F3 pressed? (2 Player)
lcomment 20B6 No, skip
lcomment 20B9 Set Bit0 = 2 Player
comment  20BC
label    20BC Test_F5
lcomment 20BE F5 pressed? (Keyboard)
lcomment 20C0 No, skip
lcomment 20C3 Reset Bit1 = Keyboard controls
comment  20C6
label    20C6 Test_F7
lcomment 20C8 F7 pressed? (Joystick)
lcomment 20CA No, skip
lcomment 20CD Set Bit1 = Joystick controls
comment  20D0
comment  20D0 Store options, update display and test for game start
label    20D0 Test_Space
lcomment 20D0 Save game settings
lcomment 20D1 0=1P+Kbd, 1=2P+Kbd, 2=1P+Jsk, 3=2P+Jsk
comment  20D7
lcomment 20D9 Select keyboard column to read
lcomment 20DC \ (2/Q/CBM/Space/Stop/Ctrl/Left/1)
lcomment 20DF Space Pressed?
lcomment 20E1 No, check for settings again
;        20E3
comment  20E3
comment  20E9
comment  20E9 ----------------------------------------------------------
comment  20E9 FUNCTION  : Update_Laser_Shots
comment  20E9 CALLED BY :
comment  20E9 CALLS     : Nothing
comment  20E9 ARGUMENTS : sentiseutn
comment  20E9 \            etinseut
comment  20E9 \            setniseutn
comment  20E9 ----------------------------------------------------------
label    20E9 Update_Laser_Shots
lcomment 20EB Update once every four calls
comment  20F0
label    20F0 Laser_Shots
const    20F3
;deflabel 20F3 ZP_03_04
lcomment 20F4
word     20F4
const    20F6
comment  20F7
comment  20F7 Loop through the four possible Laser shots, branch if any are zero I.E. NOT SHOOTING???????
label    20FB LS_Loop
comment  20FF
comment  20FF Move ZP index address to next 8 bytes i.e. next Laser shot
label    2110 Laser_Shot
lcomment 2110 Get Jetman attrib 00 i.e. fly/no-fly and facing left/right and ???
lcomment 2112 Store for later
lcomment 2113 Jetman looking left?
lcomment 2115 Set bit 4, DON'T KNOW WHAT IT'S USED FOR??????????
lcomment 2117 Store to inactive Laser attrib 00
comment  2119
lcomment 2119 Move to next Jetman attrib 01
lcomment 211A Get Jetman attrib 01 i.e. X position
lcomment 211C Zero the bottom 3 bits
lcomment 211E Set bits 0 & 2
lcomment 2120 Store for later
comment  2122
lcomment 2122 Restore Jetman attrib 00
lcomment 2123 Jetman looking left?
lcomment 2125 No, branch
label    212f Laser_Shot_
label    2145 BACK_2145
comment  2155
comment  2155 Load a random laser color using the current 6522 timer value
comment  2160
comment  2160 Not sure what this is for ??????????????
comment  216B
label    216B Laser_Color_Table
lcomment 216B Green not used, messes up colors if it's used
deflabel 216B WHITE
deflabel 216C RED
deflabel 216D CYAN
deflabel 216E PURPLE
break    216F
deflabel 216F BLUE
deflabel 2170 YELLOW
deflabel 2171 CYAN
deflabel 2172 YELLOW
comment  2173
label    2173 Laser_Jetman_Facing_Right
lcomment 2173 Get Jetman attrib 01 i.e. ????????
lcomment 2175 Zero bits 3-7, any bits 0-2 set?
lcomment 2177 No, branch
label    217E Laser_JFR_1
lcomment 217E Zero bit 0
lcomment 2180 TESING AT EDGE OF SCREEN?
label    2187 Laser_JFR_1_1
lcomment 2188 OFFSETTING EDGE OF SCREEN?
label    218D Laser_JFR_2
lcomment 218D Restore saved Jetman attrib 00
lcomment 2190 Add $10 for some reason??????????
comment  2195
comment  2195 ----------------------------------------------------------
comment  2195 FUNCTION  : Fire_Pressed_
comment  2195 \            soentsnoetus
comment  2195 \            seiteunst
comment  2195 CALLED BY :
comment  2195 CALLS     : Nothing
comment  2195 ARGUMENTS : sentiseutn
comment  2195 \            etinseut
comment  2195 \            setniseutn
comment  2195 ----------------------------------------------------------
label    2195 FP0000
label    219A Fire_Pressed_
lcomment 219A ???????
lcomment 21A0 Y=$07, laser color addr
lcomment 21A1 Fetch laser color
lcomment 21A3 Store to ZP variable
comment  21A5
comment  21A5 Get laser X and Y-coord and store to temp vars
lcomment 21A5 Y=$02, X-coord of laser horizontal end point
lcomment 21AD Y=$01, Y-coord of laser
comment  21B4
comment  21B4 Test if X-coord of laser is on a #16 boundary, update tile colour ######## NEEDS CONFIRM
comment  21C1
comment  21C1 Test if X-coord of laser is on a boundary and wrap if necessary ######## NEEDS CONFIRM
comment  21CB
label    21CB FP1111
lcomment 21CE Save A
lcomment 21D1 Get Y Coord
lcomment 21D4 Test Y coord bit 7 ???
lcomment 21D8 Get X Coord
label    21DC FP2222
lcomment 21DC Restore A
comment  21DD
comment  21DF
comment  21DF Invert the displayed 8-bit byte on-screen
comment  21E5
comment  21E5 Load current tile color, check it's not green, if not update tile color
lcomment 21E7 Zero top 4 bits
lcomment 21E9 Test if 0101
deflabel 21EA GREEN
lcomment 21ED Tile color
label    21F1 FP3333
comment  21F1
label    21FC FP4444
comment  2202
label    2202 FP5555
;        2206
word     2206
break    2209
break    220B
word     220C
comment  220F
break    220F
label    2211 FP6666
label    2229 FP7777
label    2248 FP8888
label    2257 FP9999
label    2263 FP1010
label    2285 CLC_ADC_08
label    228B Laser_ZP17_15_to_ZP16_14
label    2298 Laser_Jetman_Facing_Left???
comment  2298 Looks like it's doing some checks on the X coord, e.g. laser wraparound
lcomment 229B $B8=screen width in pixels
label    22A1 Laser_JFL
lcomment 22A1 Save Y on Stack
lcomment 22A5 Get object's type/direction byte
lcomment 22A7 Test Bit 7 is set i.e. towards left
lcomment 22AA No, branch
lcomment 22AC Restore Y from Stack
comment  22AE
lcomment 22AF Zero the top 5 bits
lcomment 22B1 Set bits 7,5,4, now it's 1011 0xxx
label    22B4 Laser_JFL_1
comment  22B4 Towards right
lcomment 22B4 Restore Y from Stack
lcomment 22B7 Zero the top 5 bits
label    22BA Reset_Level_Add_Extra_Life
comment  22B6
comment  22BD
comment  22BD Player at level 4, add another life
label    22CB RLAEL_1
label    22D1 RLAEL_2
label    22D7 RLAEL_3
label    22E3 Object_RTS_Fuel_Type
word     22EA
;        22ED
label    22ED JMP_Reset_S_O_1
break    22ED
label    22F2 Object_RMS_Gem_Type
;        22F9
word     22F9
;        22FF
label    22FF Init_Objects_1_To_3
label    2301 CBTSR1
label    230B Reset_Some_Objects
;        2315
word     2315
label    231A Reset_S_O_1
const    233B-235A
label    233B Inital_Screen_Object_Data
lcomment 233B $09=Rocket Bottom Section, $70=X, $AF=Y
lcomment 233F ???
break    233F
comment  2343
break    2343
lcomment 2343 $04=Rocket Top Section, $20=X, $3F=Y
lcomment 2347 ???
break    2347
comment  234B
lcomment 234B $04=Rocket Middle Section, $50=X, $5F=Y
lcomment 234F ???
break    234F
comment  2353
label    2353 Initial_Jetman_Obj_Params
lcomment 2353 Image, X, Move Speed, Y
lcomment 2357 Movement, ?, ?, ?
break    2357
comment  235B
label    235B Init_Next_Jetman_Lives_Scores
lcomment 235B Loop through 8 attributes
label    235D LOOP_INJLS_1
comment  2366
lcomment 2366 More time between players when 2 player game
lcomment 2369 One player game?
lcomment 236B Yes, jump
lcomment 236D Set countdown for 2 player game
lcomment 236F Store countdown
label    236F LDA_7F_Return
;        2373
comment  2373
label    2373 Display_P1_Lives
const    2376
lcomment 2376 ZP Offset for 1st address
lcomment 2377 1st Address
word     2377
comment  2382
label    2382 Display_P2_Lives
const    2385
lcomment 2385 ZP Offset for 1st address
lcomment 2386 1st Address
word     2386
comment  238E
label    238E Display_Number_Lives
lcomment 238F $70 = "0" character
comment  2396
comment  2396 Display Jetman Icon next to number of lives
word     239A
lcomment 239D 8 bytes of UDG data to copy
label    23A2 Zero_Lives_To_UDG_RAM_1
lcomment 23A8 $60 = Space character
label    23A8 Zero_Lives_To_UDG_RAM
lcomment 23AF $60 = Space character
label    23B6 Load_Num_Lives
label    23BA Load_Num_Lives_P1
label    23BD Load_Num_Lives_P2
label    23C0 Load_Num_Lives_Inverse
;        23C7
label    23C7 Jetman_Icon
const    23C7-23CE
break    23C7-23CE
bin      23C7-23CE
label    23CF LDA_7F
lcomment 23C7 ...##...
lcomment 23C8 ..#..#..
lcomment 23C9 ..####..
lcomment 23CA .######.
lcomment 23CB .#.##.#.
lcomment 23CC ..####..
lcomment 23CD ..####..
lcomment 23CE .##..##.
comment  23CF
;        23D4
comment  23D4
label    23D4 Setup_Player_Lives
label    23D6 BACK_SPL
comment  23DA
comment  23E7
label    23F4 SKIP_SPL
label    23F5 Swap_Player_And_Objects
label    23F7 Swap_Player
comment  2404
label    2406 Swap_Object
comment  2416
label    2416 Reset_Screen_Disp_Scores
lcomment 241C Puts 000000  000000  00 at top of screen
;        2425
label    2425 Display_1UP_HI_2UP_Titles
comment  2425
comment  2425 Setup address to copy data from ($2450) into UDG array for 1UP HI 2UP
lcomment 2427 3 strings to display, 1UP, HI and 2UP
;        2429
label    2429 BACK_D1H2
;        2450
label    2450 STR_1UP
break    2457
label    2457 STR_HI
break    245E
label    245E STR_2UP
;        2465
comment  2465
label    2465 STR_1UP_HI_2UP
lcomment 2465 X Y
word     2467
const    2469
lcomment 2469 X Y
word     246B
lcomment 246D X Y
word     246F
;        2471
comment  2471
label    2471 Display_P1_Score
lcomment 2474 ZP_UDG_RAM_X ZP_UDG_RAM_Y, but not in this case
lcomment 2475 UDG array absolute position to display score at
word     2475
lcomment 2477 ZP_Ptr_To_Str
lcomment 2478 Players score in ZP as BCD e.g. 12 34 56
word     2478
lcomment 247A ZP_Temp_1
const    247B
lcomment 247B 3 bytes of BCD data to display e.g. 12 34 56
word     247B
label    2481 Display_P2_Score
const    2484
lcomment 2484
lcomment 2485
word     2485
const    2487
lcomment 2487
lcomment 2488
word     2488
const    248A
lcomment 248A
lcomment 248B
word     248B
const    248B
break    248D
label    2491 Display_Hi_Score
const    2494
lcomment 2494
lcomment 2495
word     2495
const    2497
lcomment 2497
lcomment 2498
word     2498
const    249A
lcomment 249A
lcomment 249B
word     249B
const    249B
break    249D
label    24A1 Game_Sel_Flash_Period
label    24A4 GSFP1
lcomment 24A5 Test settings bit 1, if not set, skip counter logic
lcomment 24A9 Counter for flash period
lcomment 24AB remove the lsrs and flashes get faster
;        24B2
label    24B2 GSFP2
label    24B9 Display_Game_Select
;        24CA
comment  24CA
;        24CE
break    24CE
lcomment 24CE X Y
lcomment 24CD ZP_UDG_RAM_X
const    24CF
break    24D0
word     24D1
comment  24D7
lcomment 24DA ZP_UDG_RAM_X
break    24DB
lcomment 24DB X Y
break    24DD
word     24DE
comment  24E4
lcomment 24E7 ZP_Ptr_To_Str
lcomment 24E8 String address
word     24E8
comment  24EB
;        24EF
label    24EF DGS1
comment  2500
;        251F
const    251F-2523
label    251F Fn_Key_SP_Row_Offsets
;        2524
comment  2524
label    2524 STRING_COPYRIGHT_1983_ACG
lcomment 2539 Top bit=1 indicates end of string
lcomment 2539 `= Space, qyxs = 1983, n=.
label    253A STR_JETPAC_GAME_SELECT
label    2550 STR_F1_1_PLAYER_GAME
label    2562 STR_F3_2_PLAYER_GAME
label    2574 STR_F5_KEYBOARD
label    2581 STR_F7_JOYSTICK
label    258E STR_SP_START_GAME
;        259D
comment  259D
label    259D Load_ZP_Parameters
lcomment 259D
lcomment 259D Parameters for this routine are assembled into ROM after the
lcomment 259D call to this routine and accessed via the return address
lcomment 259D stored on the stack.
lcomment 259E Stash return address
comment  25A3
;        25A5
label    25A5 RZPP1
lcomment 25A5 Load next parameter value, ZP address for next param else $FF
lcomment 25A7 Value $FF?
lcomment 25A9 If No, Skip
comment  25AE
;        25B5
label    25B5 Load_ZP_Parameter
lcomment 25B5 Stash to X number before string characters (string len?)
comment  25B6
lcomment 25B6 Address starts at end of previous opcode operand, so inc it
lcomment 25B9 Y starts at 1
lcomment 25BB Store the parameter value to requried ZP address lo-byte
comment  25BD
lcomment 25BD Same again for hi-byte
comment  25C4
lcomment 25C4 Move to next parameter
lcomment 25C7 Go back and read the next parameter
;        25CA
label    25CA Inc_Param_Addr
lcomment 25CA Inc address at $40, inc lo-byte, then hi-byte if lo-byte=0
label    25D0 IPA1
;        25D1
label    25D1 Game_Start
;        25E0
comment  25E0
comment  25E0 +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
used     25E0 Hardware_Interrupt_Handler
lcomment 25E4 Reset VIA2 timer
label    25F4 HIH_1
comment  25FA
comment  25FA ----------------------------------------------------------
comment  25FA Game Main Loop
comment  25FA ----------------------------------------------------------
label    25FA Main_Loop
lcomment 25FE $03B0 = "Object_0"
lcomment 2606 Enable interrupts
label    2607 Next_Obj
lcomment 2609 Load Object Type into A from obj table 0380 upwards
lcomment 260B Mulitply by two as 2 bytes in an address
lcomment 260C Object Type becomes offset into Subroutine List
lcomment 260D Load SR List offset into SR Vec Lo/Hi...
lcomment 2617 ...and jump to it
comment  261A
label    261A Triggers_Every_Frame
lcomment 261C Test Object Type value
lcomment 261E If <>00, skip
lcomment 2622 Is Object address $B0?
lcomment 2624 If not, skip
comment  2626
comment  2626 Delay loop $100 x $02 x (2+3) = $A00 = 2,560 cycles @ 1.108MHz PAL = 0.02 Seconds (Needs Check)
label    262A Delay_Loop_0A00
comment  2630
comment  2630 Increment Object Pointer to next Obj i.e. by adding 8
label    2630 TEF_1
comment  2637
lcomment 2637 H/W interrupt happened?
lcomment 2639 If yes, jump
label    263B SEI_Load_Jetman_Rtn
comment  263B
lcomment 263B Is Object address $B0? i.e. Object_0
comment  2645
label    2652 SKIP_2652
label    2655 SKIP_2655
comment  265E
comment  265E ----------------------------------------------------------
comment  265E VIA2 timer interrupts used to update Jetman movement
comment  265E $4FD7 / 1.108Mhz = 54.2Hz interrupt. Screen is 184 pixels
comment  265E wide. At one pixel walking movement pet interrupt, Jetman
comment  265E should get across the screen in about 3.5 seconds.
comment  265E ----------------------------------------------------------
label    265E Set_Jetman_Mvmt_Speed
comment  266E
comment  2669
label    2669 SEI_Load_Jetman_To_Obj_Ptr
lcomment 2669 Set Disable Interrupts flag
comment  2676
const    2679
lcomment 2679 ZP Offset for 1st address
lcomment 267A 1st Address
word     267A
label    2680 Restore_Obj_Ptr_CLI
lcomment 2688 Clear Disable Interrupts flag
;        268C
label    268C Subroutine_List
word     268C-26AD
label    268D Subroutine_List+1
lcomment 2698 3 lines the JMP
lcomment 269A 2A6D and 2A5F almost the same
lcomment 269C 2A6D and 2A5F almost the same
;        26AE
comment  26AE
label    26AE Init_Rocket_Object
label    26B0 IRO_1
comment  26B9
comment  26B9 Probably init sound channels
label    26C5 Init_Rocket_Table
break    26C9
label    26CD Jmp_To_SRList2_SR
label    26D1 JTSRLSR_1
label    26E4 Jmp_To_SRList2_SR_
label    26F2 Copy_ZP_Val_to_ZP1_Val
label    26FE Object_Picked_Up
label    2705 Pre_Output_Sound_1
label    270A Pre_Output_Sound_2
comment  2710
comment  2710 A probably contains frequency, Y selects channel via X
label    2710 Output_Sound
label    271C Gem_Fuel_Picked_Up
label    2727 Laser_Shot_Active
label    2735 Rocket_Flight_Active
;        2743
label    2743 Subroutine_List2
word     2743-274E
label    2744 Subroutine_List2+1
comment  274F
label    274F Collision
;        275B
comment  275B Erase $100 bytes zero page
label    275B Erase_ZP_RAM
lcomment 275B Erase $100 bytes zero page
label    275E EZR_1
;        2764
label    2764 Reset_Object_RAM
label    2768 ROR_1
;        276F
label    276F Erase_HiScore_Setts_Etc
lcomment 276F Erase $30 bytes at end of UDGs $1fd0-$2000
label    2773 EHSE_1
;        277A
label    277A Check_New_Hi_Score
const    277D
lcomment 277D ZP_00
lcomment 277E Addr of High Score value
word     277E
const    2780
lcomment 2780 ZP_08
lcomment 2781 Addr of P1 High Score value
word     2781
comment  2784
lcomment 2784 Check Player 1 first
comment  2787
lcomment 2787  then follow through for Player 2
const    278A
lcomment 278A ZP_08
lcomment 278B Addr of P2 High Score value
word     278B
comment  278E
comment  278E Compare Hi Score BCD bytes
label    278E Test_New_Hi_Score
label    2790 Compare_BCD_Byte
lcomment 2796 Branch if SCORE_HI < Player Score
lcomment 2798 SCORE_HI >= Player Score, so return
label    2799 Move_To_Next_BCD_Byte
lcomment 279B All BCD bytes checked?
lcomment 279D No, check the next BCD byte
label    27A0 Copy_Player_To_Hi_Score
lcomment 27A0 3 BCD bytes, 02, 01, 00
label    27A2 CPTHS_1
lcomment 27A7 Return when all bytes copied
label    27AA Display_Rocket_Flame?
lcomment 27AE Object $0A = Flame (or maybe Rocket?)
label    27B3 Display_Rocket_Flame
comment  27B5
comment  27BD
lcomment 27C3 0019 must be height of rocket
comment  27C5
lcomment 27C5 Check rocket height
lcomment 27C7 Display Flame
lcomment 27C9 Don't display Flame
comment  27CB
label    27E1 SKIP_27E1
comment  280B
comment  280B Restore 11 and 19 and return
label    280B BACK_280B
label    2819 Display_Flame
label    2812 No_Display_Flame
;        282E
comment  282E Using A to toggle, Load A and Y with Ship UDG address
label    282E Get_Flame_UDG_Addr
;        283A
const    283A-283d
label    283A Ptr_Rocket_Flame_Lo
lcomment 283A Addr of rocket flame UDG
label    283B Ptr_Rocket_Flame_Hi
label    283C Ptr_Final_Char_Lo
lcomment 283C Addr of final char UDG
label    283D Ptr_Final_Char_Hi
comment  283E
label    283E Fire_Pressed
lcomment 2841 Remove=Gems all fall through platforms and floor, reentering at top
deflabel 2849 OBJPARAM3_JIGGLE?
label    2851 FP_1
;        286B
break    286B
const    286B
break    286D
label    2874 Jump_To_Subroutine_List3
;        2888
break    2888-2891
label    2888 Subroutine_List3
word     2888-2891
label    2889 Subroutine_List3+1
;        2892
label    2892 Set_Obj_Posn_05_To_07
label    2894 SR3_Store_To_Obj_Posn_05_06
label    289F Set_Obj_Posn_05_To_06
label    28A4 Set_Obj_Posn_05_To_03_Or_00
label    28B1 Set_Obj_Posn_05_To_03
label    28B6 Set_Obj_Posn_05_To_01_Or_Other
label    28C0 SKIP_28C0
label    28C9 Reset_Objects_1_To_8
label    28CD Loop_28CD
comment  28D4 Init Jetman, Lasers, Rocket and Aliens
label    28D4 Init_Most_Objects
label    28D8 Loop_28D8
comment  28DE
comment  28DE Init all Alien objects
label    28E0 Loop_28E0
label    28E7 Save_Obj_List_Ptr
label    28F0 Restore_Obj_List_Ptr
label    2934 Explosions_Plyr_Life_Lost?
;        2967
label    2967 Explosion_UDG_Ptr
word     2967-2974
break    2969
label    2968 Explosion_UDG_Ptr+1
break    296E
;        2987
label    2987 Game_Over
;        2997
label    2997 SKIP_2997
label    299D Sound_Channels_Off_ETC
comment  29AB
comment  29B3
comment  29BB
label    29E7 Display_Game_Over
lcomment 29EA Game Over for P1 or P2?
label    29EE Display_Game_Over_P1
lcomment 29F1 ZP_Ptr_To_Str
lcomment 29F2 Pointer to "GAME OVER PLAYER 1"
word     29F2
lcomment 29F4 ZP_UDG_RAM_X ZP_UDG_RAM_Y
lcomment 29F5 X Y
word     29F5
;        29F8
label    29F8 Display_String_
;        29FB
comment  29FB
;        29FE
lcomment 29FE Into ZP addr 02 and 03...
const    29FF
lcomment 29FF ...load 00 and 00
word     29FF
lcomment 2A01 Into ZP addr 0A and 0B
const    2A02
lcomment 2A02 ...load F8 and 00
word     2A02
;        2A05
comment  2A05
comment  2A05 Delay loop $100^2 x ($100-$f8=$08) x (5+3) = $400,000 = 4,194,304 cycles @ 1.108MHz PAL = 3.785 Seconds
label    2A05 Delay_Loop_Game_Over
lcomment 2A05 5 cycles
lcomment 2A07 3 cycles when taken, 2 when not taken
;        2A12
label    2A12 Display_Game_Over_P2
lcomment 2A15 ZP_Ptr_To_Str
lcomment 2A16 Pointer to "GAME OVER PLAYER 2"
word     2A16
const    2A18
lcomment 2A18 ZP_UDG_RAM_X ZP_UDG_RAM_Y
lcomment 2A19 X Y
word     2A19
;        2A1F
label    2A1F STR_GAME_OVER_PLAYER_1
;        2A32
break    2A32
label    2A32 STR_GAME_OVER_PLAYER_2
;        2A4C
word     2A4C
label    2A5F Lev_Start_1st_Alien_onScr
label    2A6D Not_Triggered_2A6D
label    2ABC Not_Triggered_2ABC
lcomment 2B16 Remove=(Not triggered on first level, so don't yet know)
label    2B4B Obj_Jetman_Looks?
label    2B7F Init_Rocket_Part_Fuel_Table
label    2B87 Init_Flashing_Gem_Table
;        2B82
const    2B82
const    2B8A
comment  2B7F
comment  2B87
comment  2B8F
label    2B8F Obj_Jetman_Looks_2?
const    2BCD
lcomment 2BCD
const    2BCE
lcomment 2BCE
word     2BCE
;        2BDE
label    2BDE Get_Raster_Line_Band
;        2BE8
break    2BE8-2BF7
const    2BE8-2BF7
label    2BE8 Raster_Line_Table
label    2C6A Stops_All_After_Score_Flash
lcomment 2C6F Remove=1st Level Aliens don't explode on platform/floor impact
label    2CD6 Flash_Score_Cntr_At_Zero?
const    2CDB-2CE2
label    2CDB _0025_0035_0045_0055
word     2CDB-2CE2
label    2CE3 Jetman_Looks???
label    2CF1 Jetman_Looks_1???
label    2CFF BACK_2CFF
label    2D0F Jetman_Looks_1_1???
break    2D54
comment  2D58
comment  2D58 ----------------------------------------------------------
comment  2D58 FUNCTION : Tests if Jetman and the current object have
comment  2D58 \           overlapped i.e. collided. Object can be rocket
comment  2D58 \           part, fuel pod, gem or alien.
comment  2D58 ENTRY : ZP_Obj_List_Ptr = Current Object
comment  2D58 \        Obj_Jetman_Looks = Status of Jetman
comment  2D58 EXIT  : ZP_01_Lo = $00 No hit / $80 = Collide
comment  2D58 ----------------------------------------------------------
label    2D58 Test_Jetman_Obj_Collide
lcomment 2D61 Jetman flying?
lcomment 2D63 Yes, branch
lcomment 2D65 Jetman standing?
lcomment 2D67 Yes, branch
comment  2D69
label    2D69 TJOC_0
lcomment 2D69 If Flashing Score, no collision
comment  2D6E
lcomment 2D6E Default No Collision unless tests work out
label    2D6E TJOC_1
lcomment 2D70 Reset variable
comment  2D72
lcomment 2D72 Y=1
lcomment 2D77 Compare objects X-coord vs Jetman's
comment  2D80
label    2D80 TJOC_2
lcomment 2D82 Carry Set? Yes, Return
comment  2D84
lcomment 2D84 Y=2
lcomment 2D85 Y=3
lcomment 2D8A Compare objects Y-coord vs Jetman's
comment  2D93
label    2D95 TJOC_3
lcomment 2D95 Carry Set? Yes, return
comment  2D97
lcomment 2D97 Set ZP_01_Lo = $80 and return
label    2D9B TJOC_RTS
label    2D9C TJOC_4
comment  2DA1
word     2DBC
label    2DDD LOAD_ZP1E_ZP1F_W_UDG_RAM_X_00
lcomment 2DEC Current level modulus 4
label    2DFF Dec_Saved_Obj_List_Params_by_10
comment  2E17 Aliens keep moving also
label    2E17 Rocket_Ascend
lcomment 2E1A Object height offset
lcomment 2E1C Load object height i.e. Rocket
lcomment 2E1E Object hit top yet
lcomment 2E20 Yes, branch
lcomment 2E23 Calculate new height
lcomment 2E25 Store new height i.e one pixel up
label    2E34 Rocket_At_Top
comment  2E4E Flames stop a little way before bottom
label    2E4E Rocket_Descend
comment  2E5B
comment  2E5B Move object Y position down 1 pixel, stopping at bottom i.e. $AF
lcomment 2E5B 03 = Height of object
lcomment 2E64 Hit bottom of playarea
comment  2E68
comment  2E68 Set current object type to a crash
comment  2E74
comment  2E74 This always seems to be a test for Jetman collide with Rocket
label    2E74 Subroutine_2E74_On_IRQ?
lcomment 2E77 Jetman collided with rocket?
lcomment 2E7A Set by collision test
lcomment 2E7C Collision? If no, branch
comment  2E7E
comment  2E7E Collision occured, handle it
lcomment 2E80 Get number of fuel pods delivered into rocket
lcomment 2E82 Rocket fully fueled up?
deflabel 2E83 FUELLED_UP
lcomment 2E84 No, branch
comment  2E86
comment  2E86 Set Rocket object to Ascend
deflabel 2E87 ROCKET_ASCEND
comment  2E8F
comment  2E8F Don't display Jetman next time? Also zeroes Jetman X coord.
word     2E93
comment  2E96
comment  2E9C
label    2EAC Rocket_Fuelled_Up
label    2EB5 LOOP_2EB5
comment  2EC0
label    2ECA SKIP_2ECA
label    2EFD A123123
label    2F01 A456456
label    2F07 A789789
comment  2F0D
comment  2F13
label    2F16 A111111
lcomment 2F7F Fuel cell dropped onto rocket ~8 pixels from bottom
label    2F8E Stops_All
lcomment 2FAB Remove=Rocket part & fuel keeps falling. Rocket top part only falls when middle part deposited.
;        2FE5
comment  2FE5 Using A as offset, Load A and Y with Ship UDG address
label    2FE5 Get_Object_UDG_Addr_Small
word     2FFD
label    3063 GameOverScoreStuff
lcomment 3065 If P2, setup P2 Score instead of P1 and then return after the param setup below
lcomment 306A ZP_Temp_2
lcomment 306B P1 Score in ZP
word     306B
comment  306E
label    306E Continue_Score_Process
lcomment 3070 Set Decimal Mode
lcomment 3086 Clear Decimal Mode
lcomment 3087 Decide if working with P1 or P2
label    308e P2_Score_To_UDG_RAM_
label    3091 Read_ZP_Params_P2_Score
lcomment 3094 ZP_Temp_2
lcomment 3095 P2 Score in ZP
word     3095
comment  309B
comment  309B NOT AN ENTRY POINT, CALLED FROM 30CB, $30 BYTES DOWN ??????????????
label    309B PCT_0
comment  30A1
lcomment 30A1 Save A
lcomment 30AC Restore A
comment  30AD
comment  30B3
comment  30B3 ----------------------------------------------------------
comment  30B3 Platform Collision Test
comment  30B3 ----------------------------------------------------------
comment  30B3 FUNCTION  : setsoe
comment  30B3 \            snethuoistn
comment  30B3 \            ethonshu.
comment  30B3 CALLED BY :
comment  30B3 CALLS     : Nothing
comment  30B3 ARGUMENTS : ZP_xxxx
comment  30B3 \            satoehsaeuht
comment  30B3 \            sathoeusanteho
comment  30B3 ----------------------------------------------------------
comment  30B3 Triggers with Jetman and 3 objects, then again with Jetman and different 3 objects, then...
label    30B3 Platform_Collision_Test
lcomment 30B5 1st run: Points to 03C0+1 Rocket Middle Section horizontal position = $50 i.e. #10 characters across
lcomment 30B7 1st run: Y=50
lcomment 30BB 1st run: Points to 03C0+3 Rocket Middle Section vertical   position = $5F i.e. on middle platform
lcomment 30BD 1st run: X=5f
lcomment 30BF Set Temp4 to address of data table at 31B6
label    30C2 PCT_1
lcomment 30C4 Set Temp1Lo=0
lcomment 30C6 31B6: 10 40 03 50 60 01 88 30
lcomment 30C9 1st run: 10-50=C0 i.e. -40
lcomment 30CB 1st run: Branch taken
comment  30CD
lcomment 30CD Save A
lcomment 30D3 Restore A
comment  30D4
label    30D4 PCT_02
comment  30D8
lcomment 30D8 Save A
lcomment 30DE Restore A
comment  30DF
label    30DF PCT_03
label    30EC PCT_04
label    30FD PCT_05
label    310F PCT_06
label    3118 INY_3
label    3119 INY_2
comment  3118 y reg is pointer into lookup table, 3 groups of 3
lcomment 3118 3 iny's when moving from Y check to Y check
lcomment 3119 2 iny's when moving from X check to X check as y already inc'd
lcomment 311B Temp5 used as 3-2-1 countdown
label    312D PCT_07
label    3130 PCT_08
label    3138 ORA_Temp1Lo_And_StoreTo_Temp1Lo
label    313C PCT_09
label    313D PCT_10
;        3143
label    3143 _31B6_To_Tmp4_03_To_Tmp5_Yto00
lcomment 3143 Loads address to data from $31B6 i.e. 10 40 03 50 60 01 88 30 03
label    3152 Draw_Platforms
label    3155 DP_1
lcomment 3155 Get X value from lookup table ($10)
lcomment 3157 \ and store
comment  3159
lcomment 315A Get Y value from lookup table ($40)
lcomment 315C \ and store
comment  315E
lcomment 315F Get ??? value from lookup table ($03)
lcomment 3161 \ and store
comment  3163
comment  316B
comment  316B Load Temp_3 with addr of left end platform UDG char
comment  3173
comment  3173 Copy left end platform UDG char to RAM, bytes 9 per column
comment  3178
comment  3178 Copy middle platform and right end UDG chars to RAM, 9 bytes per column
label    317B Loop_Next_Char
comment  3180
comment  3186
comment  3186 Set the color mapping for the platforms to Green
deflabel 3192 GREEN
label    3193 DP_2
label    31A2 Next_UDG_Char_Loop_Next_Char
label    31A8 Next_UDG_Char
comment  31B6 Platform data for 3143_Subroutine, 3 platforms: X Y #Num_middle_chars
const    31B6-31BE
break    31B9
break    31BC
comment  31BF
label    31BF AAAAAAAA
label    31DF BBBBBBBB
label    31CE CCCCCCCC
label    31CB EEEEEEEE
label    31D7 FFFFFFFF
label    31D4 GGGGGGGG
label    31EA HHHHHHHH
label    31E7 IIIIIIII
label    31F2 JJJJJJJJ
label    3200 KKKKKKKK
label    3208 LLLLLLLL
label    3212 MMMMMMMM
label    3215 JMP_FLYING
label    3218 NNNNNNNN
lcomment 3218 Save A
lcomment 321B Test for direction Up
lcomment 321E No, branch
lcomment 3224 Restore A
label    3228 OOOOOOOO
label    3224 PPPPPPPP
label    323E QQQQQQQQ
label    3254 LDA_08
comment  3259 HOW DO YOU EVER GET HERE?
label    325E CLC_ADC_01
label    3264 CLC_ADC_B8
label    326A ADC_48
label    326F TXA_
label    3273 Flying
lcomment 3276 Returns A=%RLDU_F111
lcomment 327B Remove=Jetman+fuel/rocket part pick-up fly through platforms
label    3285 __WWWW__
label    32A2 __YYYY__
label    32A6 __ZZZZ__
label    32BA CSC_ADC_RTN
label    32C7 Flying?
lcomment 32CB Test for direction Down
lcomment 32CE Yes, branch
lcomment 32D0 Test for direction Up
lcomment 32D3 Yes, branch
label    32DE Flying_1?
label    32E0 Flying_2?
lcomment 32E8 AF=Bottom of screen
label    32F7 Flying_3?
label    32F9 Flying_4?
lcomment 3301 Test for direction Right
lcomment 3304 No, branch
label    3309 SKIP_Flying_5?
label    330C Not_sure_330c
label    3318 LDA00
label    331D Bottom?
label    3321 Bottom_After?
label    334D Flash_Score_Then_Display_Scores
label    3367 JMP_to_Subroutine_261A
label    336A Read_Kbd_Jstk
lcomment 3370 Remove=Jetman+pickup flies/walks jiggle when standing on a platform
lcomment 33B3 Test for direction Up
lcomment 33B5 Yes, branch
comment  33D4
comment  33D4 VIA Port A Bit 2=Up, 3=Down, 4=Left, 5=Fire
comment  33D4 VIA Port B Bit 7=Left
comment  33D4 Port A read twice, 1st for Up/Down/Left, 2nd for Fire
comment  33D4 Port B read once for Right
label    33D4 Read_Joystick
lcomment 33D4 %xxFL_DU00, reads $7C=%0111_1100 when nothing pressed
lcomment 33D8 Leaves %FLDU_0000
lcomment 33D9 Set bits 7, 1-4, leaving %1LDU_1111
lcomment 33DB Nothing pressed, byte=$FF at this point
comment  33DD
comment  33DD Read Fire button
lcomment 33DD Same as above
lcomment 33E1 Leaves %xxxx_FLDU
lcomment 33E2 Set bits 0-2 & 5-8, leaving %1111_F111
lcomment 33E4 Merge result into previous reading and store
lcomment 33E6 Leaves %1LDU_F111
comment  33E8
comment  33E8 Read direction Right
lcomment 33EA Set Port B direction all lines read, probably
lcomment 33ED %xxxx_Rxxx, reads $FF=%1111_1111 when nothing pressed
lcomment 33F0 Set bits 0-6, leaving %R111_1111
lcomment 33F2 Merge result into previous reading and store
lcomment 33F4 Leaves %RLDU_F111
label    33F7 Read_Keyboard_Joystick
lcomment 33FA Joystick selected?
label    345C SKIP_345C
label    3465 Flash_Score
lcomment 3467 P1 or P2? Branch if P2
const    346C
lcomment 346C Store to ZP_UDG_RAM_X
lcomment 346D X Y position in pixels
const    346D
break    346F
label    3470 _Flash_Score_
lcomment 3479 Number of 8-bit wide characters to reverse
label    347B Invert_UDG_Columns
lcomment 347B Number of pixel lines to reverse
label    347D Invert_UDG_Rows
lcomment 347D Get current byte of character
lcomment 347F \ invert it
lcomment 3481 \ and write it back
lcomment 3484 All bytes inverted?
lcomment 3486 \ If yes, continue to next column
lcomment 3487 All columns inverted? If yes, finish
comment  3489
comment  3489 Move to next column by adding $B0 (#176) pixel to X postion
comment  3490
comment  3490 Move to top row by adding $B0 (#176) pixeln to X postion i.e. one column
lcomment 348C $B0 = height of screen in pixels i.e. move one column right
lcomment 3492 Add the carry from the previous $B0 addition for X
label    3499 Do_RTS
label    349A Load_UDG_RAM_for_P2
;        349D
lcomment 349D Store to ZP_UDG_RAM_X
const    349E
lcomment 349E X Y position in pixels
break    34A0
;        34A4
comment  34A4
comment  34A4 ----------------------------------------------------------
comment  34A4 Display_BCD_Bytes
comment  34A4 ----------------------------------------------------------
comment  34A4 FUNCTION  : Display
comment  34A4 \            Scores
comment  34A4 CALLED BY :
comment  34A4 CALLS     :
comment  34A4 ARGUMENTS : ZP_UDG_RAM_X ZP_UDG_RAM_Y = UDG array absolute position to display score at
comment  34A4 \            ZP_Ptr_To_Str             = Players score in ZP as BCD e.g. 12 34 56
comment  34A4 \            ZP_Temp_1                 = BCD byte counter i.e. number of bytes to display
comment  34A4 ----------------------------------------------------------
label    34A4 Display_BCD_Bytes
lcomment 34A4 Pointer to raw 12 34 56 in ZP
lcomment 34A6 Load first score byte i.e. 12
lcomment 34A8 Divide by $10
lcomment 34AB 12 has become 01
lcomment 34AD Add $70, $40 gets subtracted later on
lcomment 34AF and resultant $31st char in Char ROM is "1"
;        34B4
comment  34B4
comment  34B4 Display 2nd score character
lcomment 34B6 Load first score byte again i.e. 12
lcomment 34B8 Mask top 4 bits, 12 becomes 02
;        34C1
comment  34C1
comment  34C1 Increment pointer to next score byte
lcomment 34C5 Looks like a bug, should be incrementing ZP_Ptr_To_Str_Hi
label    34C7 SKIP_34C7
lcomment 34C7 Decrement number of bytes to display counter
lcomment 34C9 If <> 0 yet, process another byte
;        34CC
comment  34CC
comment  34CC ----------------------------------------------------------
comment  34CC NOT SURE WHAT THIS IS YET
comment  34CC ----------------------------------------------------------
comment  34CC FUNCTION  :
comment  34CC CALLED BY :
comment  34CC CALLS     :
comment  34CC ARGUMENTS :
comment  34CC ZP_PTR_TO_STR  = "COPYRIGHT`qyxs`An" or "JETPAC`GAME`SELEC"
comment  34CC ZP_ColorRAMPtr = "SP START GAME" or "JETPAC`GAME`SELEC"
comment  34CC ZP_UDG_RAM_X   = 08 A8 or 08 20
comment  34CC ZP_UDG_RAM_Y   = 08 A8 or 08 20
comment  34CC ZP_Addr_From   = 70 80 or 28 80
comment  34CC ----------------------------------------------------------
label    34CC Display_String
;        34D2
label    34D2
lcomment 34D2 Y=string character pointer
lcomment 34D4 Get character to display
;        34D6
label    34D6 DSTR1
lcomment 34D6 Stash character to X
lcomment 34D7 Inc character pointer
lcomment 34DA Test if character top bit is set = string end
lcomment 34DB Display character then exit
lcomment 34DD Display character
;        34E3
comment  34E3
label    34E3 Display_Character
;        34E9
comment  34E9
comment  34F0
;        34F7
label    34F7 Setup_Color_RAM_Ptr
lcomment 34F7 Get Addr_To lo-byte and divide by 8
lcomment 34F9 and store to Color RAM Ptr lo-byte.
lcomment 34FA ZP_Addr_To is used to work out the column
;        34FE
comment  34FE
lcomment 34FE Get Addr_To hi-byte, divide by $10
lcomment 3500 and use as index into Color RAM
lcomment 3501 Row Offsets i.e. 9600, 9617, 962e etc.
lcomment 3502 Divided by #16 because 16 y-pixels per
lcomment 3503 Color RAM tile.
comment  350D
lcomment 350D Store hi-byte of Color RAM
lcomment 350F to pointer hi-byte.
;        3512
const    3512-351C
label    3512 Color_RAM_Row_Offsets
;        351D
comment  351D
label    351D Setup_UDG_RAM_XY
lcomment 351D Addr_To = 18 68, as example
lcomment 351F Addr_To = 18 xx, 68 stashed to Y
comment  3520
lcomment 3520 Get Addr_To lo-byte, divide by 8, example = $18/8=3
lcomment 3526 Load Column offset (4th item = $21)
lcomment 3529 Store back to Addr_To lo-byte, Addr_To = 21 xx
;        352B
lcomment 352B Reset Addr_To hi-byte to 00
lcomment 352D Addr_To = 21 xx
;        352F
comment  352F
lcomment 352F Rotate left Addr_To by 4 bits
;        3531
label    3531 SURP1
lcomment 3536 Addr_To = 1x x2
;        3538
comment  3538
lcomment 3538 Get stashed Y = 68 to A
lcomment 353C Addr_To = 78 x2
lcomment 3542 Addr_To = 78 12 = "F7 JOYSTICK" start position
;        3545
const    3545-3557
label    3545 UDG_RAM_Column_Offsets
lcomment 3545 Bytes are middle two numbers in addr e.g. 10b0, 1160 etc
comment  355C
comment  355C ----------------------------------------------------------
comment  355C Reset RAM by filling with a data byte
comment  355C ----------------------------------------------------------
comment  355C ARGUMENTS : ZP_01 = number of bytes to fill
comment  355C \            ZP_02 = start address to fill from
comment  355C \            ZP_04 = Data byte to fill with
comment  355C ----------------------------------------------------------
label    355C Reset_Color_RAM
const    355F
lcomment 3560 Number of bytes to fill
word     3560
const    3562
lcomment 3563 Start address of bytes to fill
word     3563
const    3565
lcomment 3566 Data to fill with (i.e. $01)
const    3566
break    3566
break    3568
comment  356C
label    356C Reset_UDG_RAM
const    356F
lcomment 3570 Number of bytes to fill
const    3570
word     3570
const    3572
lcomment 3573 Start address of bytes to fill
word     3573
const    3575
lcomment 3576 Data to fill with (i.e. $00)
const    3576
break    3576
break    3578
comment  3579
label    3579 Reset_RAM
label    357B FR_1
label    3584 FR_2
;        3595
comment  3595
comment  3595 ----------------------------------------------------------
comment  3595 Copy Character ROM Character to User-Defined Graphics Memory
comment  3595 ----------------------------------------------------------
comment  3595 FUNCTION  : Copy an 8 byte Character ROM character to the
comment  3595 \            Used-Defined Graphics RAM e.g. to display a
comment  3595 \            text string or score.
comment  3595 CALLED BY :
comment  3595 CALLS     : Nothing
comment  3595 ARGUMENTS : ??? = Loaded with character to copy e.g. $71 for "1"
comment  3595 \            ??? BROKEN COMMENTS Addr_To is already setup, e.g. $1268 in UDG memory "F5 Keyboard".
comment  3595 \            ??? BROKEN COMMENTS Addr_To gets updated as part of this routine.
comment  3595 ----------------------------------------------------------
label    3595 Copy_Char_To_UDG_RAM
lcomment 3595 Addr_From = 71 xx as example
lcomment 3597 Clear address hi-byte
lcomment 3599 Addr_From = 71 00
lcomment 359E Addr_From = 31 00, $31st Character ROM character is "1"
;        35A0
comment  35A0
comment  35A0 Multiply Addr_From by 8, as 8 bytes per UDG RAM character definition
label    35A2 CCTUR1
;        35A5
lcomment 35A5 Addr_From = 31 00 > 62 00 > c4 00 > 88 01 i.e. $0188
lcomment 35A7 Left-shifted 3 times? i.e. multiplied by 8
lcomment 35A8 If no, loop back
;        35AA
comment  35AA
comment  35AA Add $8000 Character ROM offset to address
lcomment 35AE Addr_From = 88 81 i.e. $8188 is Character ROM character "1"
;        35B0
comment  35B0
comment  35B0 Copy 8 bytes to form a complete character
lcomment 35B2 Test the Invert flag
lcomment 35B4 If yes, copy bytes with inversion instead
label    35B6 CCTUR2
lcomment 35B6 Copy bytes from given address with Y offset
lcomment 35B8 Copy bytes to given address with Y offset
lcomment 35BA Decrement number of lines counter
lcomment 35BB All lines copied? If no, loop back.
;        35BD
comment  35BD
comment  35BD Move the next character address to the next column
label    35BD CCTUR_NEXT
;        35C0
lcomment 35C0 #B0=176=number of vertical pixels i.e. move to next char right
lcomment 35C6 Increment address hi-byte if previous addition overflowed
;        35CB
comment  35CB
comment  35CB Copy 8 inverted bytes to form a complete character
label    35CB CCTUR_INV
lcomment 35CB Copy bytes from given address with Y offset
lcomment 35CD Invert the byte (used to make the byte flash)
lcomment 35CF Move bytes to given address with Y offset
lcomment 35D1 Decrement number of lines counter
lcomment 35D2 All lines copied? If no, loop back.
lcomment 35D4 If yes, routine ends
label    35D7 Save_Obj_Type_X_Y
comment  35DD
comment  35E2
label    35E9 Save_Obj_Type_X_Y_Color
lcomment 35EB Object Type
comment  35EF
lcomment 35F0 Object X
comment  35F4
lcomment 35F6 Object Y
comment  35FA
lcomment 35FC Object Color
label    364C GOTO_364C
label    3674 BACK_3674
label    3688 GOTO_3688
label    36AB SKIP_36AB
label    369C BACK_36AB
label    36E7 GOTO_36E7
label    371F SKIP_371F
label    3722 SKIP_3722
label    37D4 GOUA_1
comment  37DB
comment  37ED
comment  37ED A=Saved Obj Type, X=Saved Object X AND $06/%110
comment  37ED But if it's the Jetman Object, Obj Type is instead Jetman Looks
comment  37ED and so $3F is masking out direction and test for walking AND flying???
comment  37ED CALLED ONLY FROM 381C
label    37ED Get_Object_UDG_Addr
lcomment 37EE Mask out bits 6 & 7
binary   37EF
lcomment 37f0 Test bits 0 & 1
binary   37F1
lcomment 37F2 If A >= M, branch
comment  37F5
comment  37F5 Test Jetman Looks Left/Right Direction???
comment  37FA
lcomment 37FC Set bit 3
binary   37Fd
comment  3800
comment  3800 Subtract 1 and muliply by $10 i.e. left shift 4 bits
label    3800 GOUA_2
comment  3807
comment  3807 Set bit in X defined by A, ZP variable being used as temp store
label    3807 GOUA_3
comment  380D
comment  380D Using X just set, get index into the Object UDG table
lcomment 380D Address lo byte into Y
lcomment 3811 Address hi byte into A
label    3815 Get_Object_UDG_Address
lcomment 3815 Saved Object X
lcomment 381A Saved Object Type
comment  381F
label    383B BACK_383B
label    383F BACK_383F
label    384B SKIP_384B
label    385E SKIP_385E
;        End
; End of file contains graphics data
;unused  3861-3fff ; TEMP STOP THE OUTPUT OF THE GRAPHICS
label    385F UDG_Lookup
label    3860 UDG_Lookup+1
break    385F-3FFF ; Output one byte per line
word     385F-3896
comment  3897
binary   3897-3C86
byte     3C87-3C88
const    3C87-3C88
word     3C89-3CB0
binary   3CB1-3FFF
;        38CA
label    38CA Jetman_Fly_Right_1
label    38FD Jetman_Walk_Right_1
label    3930 Jetman_Walk_Right_2
label    397B Jetman_Walk_Right_3
label    39C6 Jetman_Walk_Right_4
label    39F9 Jetman_Walk_Left_1
label    3A2C Jetman_Walk_Left_2
label    3A77 Jetman_Walk_Left_3
label    3AC2 Jetman_Walk_Left_4
label    3AF5 Jetman_Fly_Left_1
label    3B40 Jetman_Fly_Left_2
label    3B8B Jetman_Fly_Left_3
label    3BBE Jetman_Fly_Right_2
label    3BF1 Jetman_Fly_Right_3
label    3C3C Jetman_Fly_Right_4
lcomment 3C87 $3CD4 = Ship_1_Bott
label    3C87 UDG_Sprite_Lookup_Lo
label    3C88 UDG_Sprite_Lookup_Hi
label    3E46 Alien_Ship_1
label    3E61 Alien_Ship_2
label    3E78 Alien_Fuzz_1
label    3E99 Alien_Fuzz_2
label    3EB8 Alien_Bubble_1
label    3EEB Alien_Bubble_2
label    3F0E Alien_Cross_1
label    3F41 Alien_Cross_2
label    3CD4 Ship_1_Bott
label    3CF7 Ship_1_Mid
label    3D1A Ship_1_Top
label    3D3D Ship_2_Bott
label    3D60 Ship_2_Mid
label    3D83 Ship_2_Top
label    3D9C Fuel
label    3DAF Gold_Bar
label    3DCA Diamond
label    3DE3 Plutonium
label    3E00 Isotope
label    3E15 Platform ; Not Mineral? So we shift them all up one?
label    3F74 Explosion_1
label    3F9B Explosion_2
label    3FB2 Explosion_3
